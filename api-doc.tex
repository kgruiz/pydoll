\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{listings}
\usepackage{url}
\usepackage{hyperref}
\usepackage{xcolor}
\usepackage{pgf} % Required for true transparency



\definecolor{keywordcolor}{rgb}{0,0,1}
\definecolor{commentcolor}{rgb}{0.5,0.5,0.5}
\definecolor{stringcolor}{rgb}{0.6,0,0}

\lstdefinestyle{pythonstyle}{%
    language=Python,
    basicstyle=\ttfamily\normalsize,
    keywordstyle=\color{keywordcolor}\bfseries,
    commentstyle=\color{commentcolor}\itshape,
    stringstyle=\color{stringcolor},
    showstringspaces=false,
    % frame=single,
    frame=none,
    % numbers=left,
    numbers=none,
    % numberstyle=\tiny\color{commentcolor},
    breaklines=true,
    tabsize=4,
    morekeywords={self}
}

\title{Pydoll - Python Chrome DevTools Protocol Library}
\author{Repo: thalissonvs, This doc: kgruiz}
\date{}

\begin{document}

\maketitle

\noindent\textbf{Source repo:} \url{https://github.com/thalissonvs/pydoll}

\begin{abstract}
    Pydoll is a Python library designed to simplify interaction with the Chrome DevTools Protocol (CDP). It provides an object-oriented interface for automating and controlling Chromium-based browsers, enabling tasks such as web scraping, automated testing, and performance analysis. Pydoll is built to be asynchronous, leveraging \lstinline[style=pythonstyle]|asyncio| for efficient and non-blocking operations.
\end{abstract}

\newpage

\tableofcontents

\newpage

\section{Conceptual Overview}

\noindent Pydoll is structured around the core concept of interacting with a browser instance through the Chrome DevTools Protocol. Here's a breakdown of the key components:

\begin{itemize}
    \item \textbf{Browser Class:} The central class (\lstinline[style=pythonstyle]|Browser|) is responsible for managing the browser process lifecycle. It handles starting, stopping, and configuring the browser. It also provides methods for global browser-level operations like setting download paths and managing cookies.
    \item \textbf{Page Class:} The \lstinline[style=pythonstyle]|Page| class represents a single tab or page within the browser. It offers methods for interacting with the content of a page, such as navigation, taking screenshots, executing JavaScript, and finding elements in the DOM.
    \item \textbf{WebElement Class:} Instances of \lstinline[style=pythonstyle]|WebElement| represent DOM elements on a web page. They provide methods for interacting with elements, such as clicking, sending keys, getting attributes, and retrieving text content.
    \item \textbf{Commands Modules:} Organized into submodules (\lstinline[style=pythonstyle]|browser|, \lstinline[style=pythonstyle]|dom|, \lstinline[style=pythonstyle]|fetch|, \lstinline[style=pythonstyle]|input|, \lstinline[style=pythonstyle]|network|, \lstinline[style=pythonstyle]|page|, \lstinline[style=pythonstyle]|runtime|, \lstinline[style=pythonstyle]|storage|, \lstinline[style=pythonstyle]|target|), these modules contain classes (e.g., \lstinline[style=pythonstyle]|BrowserCommands|, \lstinline[style=pythonstyle]|DomCommands|) that encapsulate the raw CDP commands. These are lower-level building blocks used by the \lstinline[style=pythonstyle]|Browser| and \lstinline[style=pythonstyle]|Page| classes.
    \item \textbf{Events Modules:} Similar to commands, event modules (\lstinline[style=pythonstyle]|browser|, \lstinline[style=pythonstyle]|dom|, \lstinline[style=pythonstyle]|fetch|, \lstinline[style=pythonstyle]|network|, \lstinline[style=pythonstyle]|page|) define classes (e.g., \lstinline[style=pythonstyle]|BrowserEvents|, \lstinline[style=pythonstyle]|DomEvents|) that list the available CDP events. Pydoll provides mechanisms to register callbacks for these events, allowing your application to react to browser activities in real-time.
    \item \textbf{Connection Handling:} The \lstinline[style=pythonstyle]|ConnectionHandler| class manages the WebSocket connection to the browser, sending commands and receiving event messages.
    \item \textbf{Managers:} Manager classes (\lstinline[style=pythonstyle]|BrowserOptionsManager|, \lstinline[style=pythonstyle]|BrowserProcessManager|, \lstinline[style=pythonstyle]|ProxyManager|, \lstinline[style=pythonstyle]|TempDirectoryManager|) handle specific aspects of browser setup and management, such as options processing, process control, proxy configuration, and temporary directory management.
\end{itemize}

\noindent Pydoll aims to abstract away the complexity of the raw CDP, providing a more Pythonic and user-friendly API for browser automation.

\section{Basic Usage}

\subsection{Installation}

\begin{lstlisting}[language=bash]
pip install pydoll
\end{lstlisting}

\subsection{Importing the main class}

\begin{lstlisting}[language=Python]
from pydoll.browser.chrome import Chrome
from pydoll.browser.options import Options
\end{lstlisting}

\subsection{Starting and stopping a browser}

\begin{lstlisting}[language=Python]
import asyncio

async def main():
    async with Chrome() as browser:
        await browser.start()
        page = await browser.get_page()
        await page.go_to("https://www.example.com")
        print(await page.current_url) # >>> https://www.example.com/
        await browser.stop()

if __name__ == "__main__":
    asyncio.run(main())
\end{lstlisting}

\subsection{Customizing browser options}

\begin{lstlisting}[language=Python]
import asyncio
from pydoll.browser.chrome import Chrome
from pydoll.browser.options import Options

async def main():
    options = Options()
    options.add_argument("--headless") # Run in headless mode
    options.binary_location = "/path/to/your/chrome/binary" # Specify Chrome binary path

    async with Chrome(options=options) as browser:
        await browser.start()
        page = await browser.get_page()
        await page.go_to("https://www.example.com")
        print(await page.current_url)
        await browser.stop()

if __name__ == "__main__":
    asyncio.run(main())
\end{lstlisting}

\section{API Reference}
\hrulefill

\subsection*{\texttt{pydoll.browser} Module}

\subsubsection*{\texttt{class pydoll.browser.base.Browser}}
\noindent\texttt{class Browser(ABC)}

\noindent A class to manage a browser instance for automated interactions.

\noindent This class allows users to start and stop a browser, take screenshots, and register event callbacks.

\paragraph{Constructor}

\begin{lstlisting}[style=pythonstyle]
def __init__(self, options: Options | None = None, connection_port: int = None):
\end{lstlisting}

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|options| (\lstinline[style=pythonstyle]|Options | None|): Configuration options.
    \item \lstinline[style=pythonstyle]|connection_port| (\lstinline[style=pythonstyle]|int|): The port to connect to the browser. If \lstinline[style=pythonstyle]|None|, a random port between 9223 and 9322 will be used.
\end{itemize}

\paragraph{Raises}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|TypeError|: If any of the arguments are of an incorrect type.
\end{itemize}

\paragraph{Asynchronous Context Manager Methods}
\paragraph{async def \_\_aenter\_\_}

\begin{lstlisting}[style=pythonstyle]
async def __aenter__(self):
\end{lstlisting}

\noindent Enters the asynchronous context. Returns the \lstinline[style=pythonstyle]|Browser| instance.

\paragraph{async def \_\_aexit\_\_}

\begin{lstlisting}[style=pythonstyle]
async def __aexit__(self, exc_type, exc_val, exc_tb):
\end{lstlisting}

\noindent Exits the asynchronous context. Automatically stops the browser and closes the connection.

\paragraph{Methods}
\paragraph{async def start}

\begin{lstlisting}[style=pythonstyle]
async def start(self) -> None:
\end{lstlisting}

\noindent Starts the browser process.

\paragraph{Raises}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|BrowserNotRunning|: If the browser fails to start.
\end{itemize}

\paragraph{async def stop}

\begin{lstlisting}[style=pythonstyle]
async def stop(self) -> None:
\end{lstlisting}

\noindent Stops the running browser process.

\paragraph{Raises}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|ValueError|: If the browser is not currently running.
    \item \lstinline[style=pythonstyle]|BrowserNotRunning|: If the browser is not running.
\end{itemize}

\paragraph{async def set\_download\_path}

\begin{lstlisting}[style=pythonstyle]
async def set_download_path(self, path: str):
\end{lstlisting}

\noindent Sets the download path for the browser.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|path| (\lstinline[style=pythonstyle]|str|): The path to the download directory.
\end{itemize}

\paragraph{async def get\_page\_by\_id}

\begin{lstlisting}[style=pythonstyle]
async def get_page_by_id(self, page_id: str) -> Page:
\end{lstlisting}

\noindent Retrieves a \lstinline[style=pythonstyle]|Page| instance by its ID.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|page_id| (\lstinline[style=pythonstyle]|str|): The ID of the page to retrieve.
\end{itemize}

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|Page|: The \lstinline[style=pythonstyle]|Page| instance corresponding to the specified ID.
\end{itemize}

\paragraph{async def get\_page}

\begin{lstlisting}[style=pythonstyle]
async def get_page(self) -> Page:
\end{lstlisting}

\noindent Retrieves a \lstinline[style=pythonstyle]|Page| instance for an existing page in the browser. If no pages are open, a new page will be created.

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|Page|: The \lstinline[style=pythonstyle]|Page| instance.
\end{itemize}

\paragraph{async def delete\_all\_cookies}

\begin{lstlisting}[style=pythonstyle]
async def delete_all_cookies(self):
\end{lstlisting}

\noindent Deletes all cookies from the browser.

\paragraph{async def set\_cookies}

\begin{lstlisting}[style=pythonstyle]
async def set_cookies(self, cookies: list[dict]):
\end{lstlisting}

\noindent Sets cookies in the browser.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|cookies| (\lstinline[style=pythonstyle]|list[dict]|): A list of dictionaries containing the cookie data.
\end{itemize}

\paragraph{async def get\_cookies}

\begin{lstlisting}[style=pythonstyle]
async def get_cookies(self) -> list[dict]:
\end{lstlisting}

\noindent Retrieves all cookies from the browser.

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|list[dict]|: A list of dictionaries containing the cookie data.
\end{itemize}

\paragraph{async def on}

\begin{lstlisting}[style=pythonstyle]
async def on(self, event_name: str, callback: callable, temporary: bool = False) -> int:
\end{lstlisting}

\noindent Registers an event callback for a specific event. This method has a global scope and can be used to listen for events across all pages in the browser. Each \lstinline[style=pythonstyle]|Page| instance also has an \lstinline[style=pythonstyle]|on| method that allows for listening to events on a specific page.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|event_name| (\lstinline[style=pythonstyle]|str|): Name of the event to listen for (e.g., from \lstinline[style=pythonstyle]|PageEvents|, \lstinline[style=pythonstyle]|NetworkEvents|, etc.).
    \item \lstinline[style=pythonstyle]|callback| (\lstinline[style=pythonstyle]|Callable|): Function to be called when the event occurs.
    \item \lstinline[style=pythonstyle]|temporary| (\lstinline[style=pythonstyle]|bool|, optional): If \lstinline[style=pythonstyle]|True|, the callback will be automatically removed after it is triggered once. Defaults to \lstinline[style=pythonstyle]|False|.
\end{itemize}

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|int|: The ID of the registered callback.
\end{itemize}

\paragraph{async def new\_page}

\begin{lstlisting}[style=pythonstyle]
async def new_page(self, url: str = '') -> str:
\end{lstlisting}

\noindent Opens a new page in the browser.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|url| (\lstinline[style=pythonstyle]|str|, optional): URL to navigate to in the new page. Defaults to an empty string (new tab page).
\end{itemize}

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|str|: The \lstinline[style=pythonstyle]|targetId| of the new page.
\end{itemize}

\paragraph{async def get\_targets}

\begin{lstlisting}[style=pythonstyle]
async def get_targets(self) -> list[dict]:
\end{lstlisting}

\noindent Retrieves the list of open pages in the browser.

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|list[dict]|: The list of open pages in the browser, each represented as a dictionary with target information.
\end{itemize}

\paragraph{async def get\_window\_id}

\begin{lstlisting}[style=pythonstyle]
async def get_window_id(self) -> str:
\end{lstlisting}

\noindent Retrieves the ID of the current browser window.

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|str|: The ID of the current browser window.
\end{itemize}

\paragraph{async def set\_window\_bounds}

\begin{lstlisting}[style=pythonstyle]
async def set_window_bounds(self, bounds: dict):
\end{lstlisting}

\noindent Sets the bounds of the specified window.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|bounds| (\lstinline[style=pythonstyle]|dict|): The bounds to set for the window. This should be a dictionary containing keys like \lstinline[style=pythonstyle]|'width'|, \lstinline[style=pythonstyle]|'height'|, \lstinline[style=pythonstyle]|'x'|, \lstinline[style=pythonstyle]|'y'|, and \lstinline[style=pythonstyle]|'windowState'|.
\end{itemize}

\paragraph{async def set\_window\_maximized}

\begin{lstlisting}[style=pythonstyle]
async def set_window_maximized(self):
\end{lstlisting}

\noindent Maximizes the specified window.

\paragraph{async def set\_window\_minimized}

\begin{lstlisting}[style=pythonstyle]
async def set_window_minimized(self):
\end{lstlisting}

\noindent Minimizes the specified window.

\paragraph{async def enable\_page\_events}

\begin{lstlisting}[style=pythonstyle]
async def enable_page_events(self):
\end{lstlisting}

\noindent Enables listening for page-related events over the websocket connection globally for the browser.

\paragraph{async def enable\_network\_events}

\begin{lstlisting}[style=pythonstyle]
async def enable_network_events(self):
\end{lstlisting}

\noindent Activates listening for network events through the websocket connection globally for the browser.

\paragraph{async def enable\_fetch\_events}

\begin{lstlisting}[style=pythonstyle]
async def enable_fetch_events(self, handle_auth_requests: bool = False, resource_type: str = ""):
\end{lstlisting}

\noindent Enables the Fetch domain for intercepting network requests before they are sent globally for the browser.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|handle_auth_requests| (\lstinline[style=pythonstyle]|bool|, optional): Whether to handle authentication requests that require user credentials. Defaults to \lstinline[style=pythonstyle]|False|.
    \item \lstinline[style=pythonstyle]|resource_type| (\lstinline[style=pythonstyle]|str|, optional): The type of resource to intercept (e.g., \lstinline[style=pythonstyle]|'XHR'|, \lstinline[style=pythonstyle]|'Script'|). If not specified, all requests will be intercepted. Defaults to \lstinline[style=pythonstyle]|''|.
\end{itemize}

\paragraph{async def enable\_dom\_events}

\begin{lstlisting}[style=pythonstyle]
async def enable_dom_events(self):
\end{lstlisting}

\noindent Enables DOM-related events for the websocket connection globally for the browser.

\paragraph{async def disable\_fetch\_events}

\begin{lstlisting}[style=pythonstyle]
async def disable_fetch_events(self):
\end{lstlisting}

\noindent Deactivates the Fetch domain, stopping the interception of network requests for the websocket connection globally for the browser.

\subsubsection*{\texttt{class pydoll.browser.chrome.Chrome}}
\noindent\texttt{class Chrome(Browser)}

\noindent A subclass of \lstinline[style=pythonstyle]|Browser| specifically for managing Google Chrome instances.

\paragraph{Constructor}

\begin{lstlisting}[style=pythonstyle]
def __init__(self, options: Options | None = None, connection_port: int | None = None):
\end{lstlisting}

\noindent Initializes a \lstinline[style=pythonstyle]|Chrome| browser instance. Inherits from \lstinline[style=pythonstyle]|Browser.__init__|.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|options| (\lstinline[style=pythonstyle]|Optional[Options]|, optional): Browser options. Defaults to \lstinline[style=pythonstyle]|None|.
    \item \lstinline[style=pythonstyle]|connection_port| (\lstinline[style=pythonstyle]|Optional[int]|, optional): Connection port. Defaults to \lstinline[style=pythonstyle]|None|.
\end{itemize}

\subsubsection*{\texttt{class pydoll.browser.managers.BrowserOptionsManager}}
\noindent Manages browser options initialization and validation.

\paragraph{Static Methods}
\paragraph{@staticmethod initialize\_options}

\begin{lstlisting}[style=pythonstyle]
@staticmethod
def initialize_options(options: Options | None) -> Options:
\end{lstlisting}

\noindent Initializes browser options.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|options| (\lstinline[style=pythonstyle]|Options | None|): Options instance or \lstinline[style=pythonstyle]|None| for default options.
\end{itemize}

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|Options|: Initialized options instance.
\end{itemize}

\paragraph{Raises}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|ValueError|: If \lstinline[style=pythonstyle]|options| is not an instance of \lstinline[style=pythonstyle]|Options|.
\end{itemize}

\paragraph{@staticmethod add\_default\_arguments}

\begin{lstlisting}[style=pythonstyle]
@staticmethod
def add_default_arguments(options: Options):
\end{lstlisting}

\noindent Adds default arguments to the provided options. Includes \lstinline[style=pythonstyle]|--no-first-run| and \lstinline[style=pythonstyle]|--no-default-browser-check|.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|options| (\lstinline[style=pythonstyle]|Options|): The \lstinline[style=pythonstyle]|Options| instance to modify.
\end{itemize}

\paragraph{@staticmethod validate\_browser\_path}

\begin{lstlisting}[style=pythonstyle]
@staticmethod
def validate_browser_path(path: str) -> str:
\end{lstlisting}

\noindent Validates the provided browser executable path.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|path| (\lstinline[style=pythonstyle]|str|): Path to the browser executable.
\end{itemize}

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|str|: Validated browser path.
\end{itemize}

\paragraph{Raises}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|ValueError|: If the path does not exist.
\end{itemize}

\subsubsection*{\texttt{class pydoll.browser.managers.BrowserProcessManager}}
\noindent Manages the browser process lifecycle.

\paragraph{Constructor}

\begin{lstlisting}[style=pythonstyle]
def __init__(self, process_creator=None):
\end{lstlisting}

\noindent Initializes \lstinline[style=pythonstyle]|BrowserProcessManager|.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|process_creator| (callable, optional): A custom function to create subprocesses, for testing purposes.
\end{itemize}

\paragraph{Methods}
\paragraph{start\_browser\_process}

\begin{lstlisting}[style=pythonstyle]
def start_browser_process(self, binary_location: str, port: int, arguments: list) -> subprocess.Popen:
\end{lstlisting}

\noindent Starts the browser subprocess.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|binary_location| (\lstinline[style=pythonstyle]|str|): Path to the browser executable.
    \item \lstinline[style=pythonstyle]|port| (\lstinline[style=pythonstyle]|int|): Port for remote debugging.
    \item \lstinline[style=pythonstyle]|arguments| (\lstinline[style=pythonstyle]|list|): List of browser arguments.
\end{itemize}

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|subprocess.Popen|: The process object.
\end{itemize}

\paragraph{stop\_process}

\begin{lstlisting}[style=pythonstyle]
def stop_process(self):
\end{lstlisting}

\noindent Terminates the browser process if it is running.

\subsubsection*{\texttt{class pydoll.browser.managers.ProxyManager}}
\noindent Manages proxy configurations for the browser.

\paragraph{Constructor}

\begin{lstlisting}[style=pythonstyle]
def __init__(self, options):
\end{lstlisting}
\noindent Initializes \lstinline[style=pythonstyle]|ProxyManager|.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|options| (\lstinline[style=pythonstyle]|Options|): Browser options.
\end{itemize}

\paragraph{Methods}
\paragraph{get\_proxy\_credentials}

\begin{lstlisting}[style=pythonstyle]
def get_proxy_credentials(self) -> tuple[bool, tuple[str, str]]:
\end{lstlisting}

\noindent Configures proxy settings and extracts credentials if present in the \lstinline[style=pythonstyle]|--proxy-server| argument.

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|tuple[bool, tuple[str, str]]|: A tuple containing:
          \begin{itemize}
              \item \lstinline[style=pythonstyle]|bool|: \lstinline[style=pythonstyle]|True| if a private proxy is configured (credentials found), \lstinline[style=pythonstyle]|False| otherwise.
              \item \lstinline[style=pythonstyle]|tuple[str, str]|: A tuple containing the username and password for the proxy, or \lstinline[style=pythonstyle]|(None, None)| if no credentials were found.
          \end{itemize}
\end{itemize}

\subsubsection*{\texttt{class pydoll.browser.managers.TempDirectoryManager}}
\noindent Manages temporary directories for browser data.

\paragraph{Constructor}

\begin{lstlisting}[style=pythonstyle]
def __init__(self, temp_dir_factory=TemporaryDirectory):
\end{lstlisting}

\noindent Initializes \lstinline[style=pythonstyle]|TempDirectoryManager|.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|temp_dir_factory| (callable, optional): A custom factory for creating temporary directories, for testing purposes.
\end{itemize}

\paragraph{Methods}
\paragraph{create\_temp\_dir}

\begin{lstlisting}[style=pythonstyle]
def create_temp_dir(self) -> TemporaryDirectory:
\end{lstlisting}

\noindent Creates a temporary directory for the browser instance.

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|TemporaryDirectory|: The temporary directory object.
\end{itemize}

\paragraph{cleanup}

\begin{lstlisting}[style=pythonstyle]
def cleanup(self):
\end{lstlisting}

\noindent Deletes all created temporary directories.

\subsubsection*{\texttt{class pydoll.browser.options.Options}}
\noindent\texttt{class Options()}

\noindent A class to manage command-line options for a browser instance.

\noindent This class allows the user to specify command-line arguments and the binary location of the browser executable.

\paragraph{Constructor}

\begin{lstlisting}[style=pythonstyle]
def __init__(self):
\end{lstlisting}

\noindent Initializes the \lstinline[style=pythonstyle]|Options| instance. Sets up an empty list for command-line arguments and a string for the binary location of the browser.

\paragraph{Properties}
\paragraph{arguments}

\begin{lstlisting}[style=pythonstyle]
arguments: list
\end{lstlisting}

\noindent Gets the list of command-line arguments.

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|list|: A list of command-line arguments added to the options.
\end{itemize}

\paragraph{binary\_location}

\begin{lstlisting}[style=pythonstyle]
binary_location: str
\end{lstlisting}

\noindent Gets the location of the browser binary.

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|str|: The file path to the browser executable.
\end{itemize}

\paragraph{Methods}
\paragraph{add\_argument}

\begin{lstlisting}[style=pythonstyle]
def add_argument(self, argument: str):
\end{lstlisting}

\noindent Adds a command-line argument to the options.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|argument| (\lstinline[style=pythonstyle]|str|): The command-line argument to be added.
\end{itemize}

\paragraph{Raises}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|ValueError|: If the argument is already in the list of arguments.
\end{itemize}

\hrulefill

\subsection*{\texttt{pydoll.commands} Module}

\subsubsection*{\texttt{pydoll.commands.browser} Module}

\subsubsection*{\texttt{class pydoll.commands.browser.BrowserCommands}}
\noindent BrowserCommands class provides a set of commands to interact with the browser's main functionality based on CDP\@. These commands allow for managing browser windows, such as closing windows, retrieving window IDs, and adjusting window bounds (size and state).

\paragraph{Class Attributes}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|CLOSE| (\lstinline[style=pythonstyle]|dict|): Command template to close the browser.
    \item \lstinline[style=pythonstyle]|GET_WINDOW_ID| (\lstinline[style=pythonstyle]|dict|): Command template to get the current window ID.
    \item \lstinline[style=pythonstyle]|SET_WINDOW_BOUNDS_TEMPLATE| (\lstinline[style=pythonstyle]|dict|): Template for setting window bounds.
    \item \lstinline[style=pythonstyle]|SET_DOWNLOAD_BEHAVIOR| (\lstinline[style=pythonstyle]|dict|): Template for setting download behavior.
\end{itemize}

\paragraph{Class Methods}
\paragraph{@classmethod set\_download\_path}

\begin{lstlisting}[style=pythonstyle]
@classmethod
def set_download_path(cls, path: str) -> dict:
\end{lstlisting}

\noindent Generates the command to set the download path for the browser.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|path| (\lstinline[style=pythonstyle]|str|): The path to set for downloads.
\end{itemize}

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|dict|: The command to be sent to the browser.
\end{itemize}

\paragraph{@classmethod close}

\begin{lstlisting}[style=pythonstyle]
@classmethod
def close(cls) -> dict:
\end{lstlisting}

\noindent Generates the command to close the browser.

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|dict|: The command to be sent to the browser.
\end{itemize}

\paragraph{@classmethod get\_window\_id}

\begin{lstlisting}[style=pythonstyle]
@classmethod
def get_window_id(cls) -> dict:
\end{lstlisting}

\noindent Generates the command to get the ID of the current window.

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|dict|: The command to be sent to the browser.
\end{itemize}

\paragraph{@classmethod set\_window\_bounds}

\begin{lstlisting}[style=pythonstyle]
@classmethod
def set_window_bounds(cls, window_id: int, bounds: dict) -> dict:
\end{lstlisting}

\noindent Generates the command to set the bounds of a window.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|window_id| (\lstinline[style=pythonstyle]|int|): The ID of the window to set the bounds for.
    \item \lstinline[style=pythonstyle]|bounds| (\lstinline[style=pythonstyle]|dict|): The bounds to set for the window, which should include width, height, and optionally x and y coordinates.
\end{itemize}

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|dict|: The command to be sent to the browser.
\end{itemize}

\paragraph{@classmethod set\_window\_maximized}

\begin{lstlisting}[style=pythonstyle]
@classmethod
def set_window_maximized(cls, window_id: int) -> dict:
\end{lstlisting}

\noindent Generates the command to maximize a window.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|window_id| (\lstinline[style=pythonstyle]|int|): The ID of the window to maximize.
\end{itemize}

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|dict|: The command to be sent to the browser.
\end{itemize}

\paragraph{@classmethod set\_window\_minimized}

\begin{lstlisting}[style=pythonstyle]
@classmethod
def set_window_minimized(cls, window_id: int) -> dict:
\end{lstlisting}

\noindent Generates the command to minimize a window.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|window_id| (\lstinline[style=pythonstyle]|int|): The ID of the window to minimize.
\end{itemize}

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|dict|: The command to be sent to the browser.
\end{itemize}

\subsubsection*{\texttt{pydoll.commands.dom} Module}

\subsubsection*{\texttt{class pydoll.commands.dom.DomCommands}}
\noindent A class to define commands for interacting with the Document Object Model (DOM) using the Chrome DevTools Protocol (CDP). The commands allow for various operations on DOM nodes, such as enabling the DOM domain, retrieving the DOM document, describing nodes, and querying elements.

\paragraph{Class Attributes}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|SelectorType| (\lstinline[style=pythonstyle]|Literal|): A type definition for supported selector types (\lstinline[style=pythonstyle]|By.CSS_SELECTOR|, \lstinline[style=pythonstyle]|By.XPATH|, \lstinline[style=pythonstyle]|By.CLASS_NAME|, \lstinline[style=pythonstyle]|By.ID|, \lstinline[style=pythonstyle]|By.TAG_NAME|).
    \item \lstinline[style=pythonstyle]|ENABLE| (\lstinline[style=pythonstyle]|dict|): Command template to enable DOM domain events.
    \item \lstinline[style=pythonstyle]|DOM_DOCUMENT| (\lstinline[style=pythonstyle]|dict|): Command template to get the DOM document.
    \item \lstinline[style=pythonstyle]|DESCRIBE_NODE_TEMPLATE| (\lstinline[style=pythonstyle]|dict|): Template for describing a DOM node.
    \item \lstinline[style=pythonstyle]|FIND_ELEMENT_TEMPLATE| (\lstinline[style=pythonstyle]|dict|): Template for finding a single DOM element.
    \item \lstinline[style=pythonstyle]|FIND_ALL_ELEMENTS_TEMPLATE| (\lstinline[style=pythonstyle]|dict|): Template for finding multiple DOM elements.
    \item \lstinline[style=pythonstyle]|BOX_MODEL_TEMPLATE| (\lstinline[style=pythonstyle]|dict|): Template for getting the box model of a DOM node.
    \item \lstinline[style=pythonstyle]|RESOLVE_NODE_TEMPLATE| (\lstinline[style=pythonstyle]|dict|): Template for resolving a DOM node.
    \item \lstinline[style=pythonstyle]|REQUEST_NODE_TEMPLATE| (\lstinline[style=pythonstyle]|dict|): Template for requesting a DOM node.
    \item \lstinline[style=pythonstyle]|GET_OUTER_HTML| (\lstinline[style=pythonstyle]|dict|): Template for getting the outer HTML of a DOM node.
    \item \lstinline[style=pythonstyle]|SCROLL_INTO_VIEW_IF_NEEDED| (\lstinline[style=pythonstyle]|dict|): Template for scrolling a DOM node into view if needed.
\end{itemize}

\paragraph{Class Methods}
\paragraph{@classmethod scroll\_into\_view}

\begin{lstlisting}[style=pythonstyle]
@classmethod
def scroll_into_view(cls, object_id: str) -> dict:
\end{lstlisting}

\noindent Generates the command to scroll a specific DOM node into view.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|object_id| (\lstinline[style=pythonstyle]|str|): The object ID of the DOM node.
\end{itemize}

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|dict|: The command to be sent to the browser.
\end{itemize}

\paragraph{@classmethod get\_outer\_html}

\begin{lstlisting}[style=pythonstyle]
@classmethod
def get_outer_html(cls, object_id: int) -> dict:
\end{lstlisting}

\noindent Generates the command to get the outer HTML of a DOM node.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|object_id| (\lstinline[style=pythonstyle]|int|): The object ID of the DOM node.
\end{itemize}

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|dict|: The command to be sent to the browser.
\end{itemize}

\paragraph{@classmethod dom\_document}

\begin{lstlisting}[style=pythonstyle]
@classmethod
def dom_document(cls) -> dict:
\end{lstlisting}

\noindent Generates the command to get the root DOM node of the current page.

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|dict|: The command to be sent to the browser.
\end{itemize}

\paragraph{@classmethod request\_node}

\begin{lstlisting}[style=pythonstyle]
@classmethod
def request_node(cls, object_id: str) -> dict:
\end{lstlisting}

\noindent Generates the command to request a specific DOM node by its object ID.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|object_id| (\lstinline[style=pythonstyle]|str|): The object ID of the DOM node.
\end{itemize}

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|dict|: The command to be sent to the browser.
\end{itemize}

\paragraph{@classmethod describe\_node}

\begin{lstlisting}[style=pythonstyle]
@classmethod
def describe_node(cls, object_id: str) -> dict:
\end{lstlisting}

\noindent Generates the command to describe a specific DOM node.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|object_id| (\lstinline[style=pythonstyle]|str|): The object ID of the DOM node.
\end{itemize}

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|dict|: The command to be sent to the browser.
\end{itemize}

\paragraph{@classmethod box\_model}

\begin{lstlisting}[style=pythonstyle]
@classmethod
def box_model(cls, object_id: str) -> dict:
\end{lstlisting}

\noindent Generates the command to get the box model of a specific DOM node.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|object_id| (\lstinline[style=pythonstyle]|str|): The object ID of the DOM node.
\end{itemize}

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|dict|: The command to be sent to the browser.
\end{itemize}

\paragraph{@classmethod enable\_dom\_events}

\begin{lstlisting}[style=pythonstyle]
@classmethod
def enable_dom_events(cls) -> dict:
\end{lstlisting}

\noindent Generates the command to enable the DOM domain events.

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|dict|: The command to be sent to the browser.
\end{itemize}

\paragraph{@classmethod get\_current\_url}

\begin{lstlisting}[style=pythonstyle]
@classmethod
def get_current_url(cls) -> dict:
\end{lstlisting}

\noindent Generates the command to get the current URL of the page.

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|dict|: The command to be sent to the browser.
\end{itemize}

\paragraph{@classmethod find\_element}

\begin{lstlisting}[style=pythonstyle]
@classmethod
def find_element(cls, by: SelectorType, value: str, object_id: str = '') -> dict:
\end{lstlisting}

\noindent Generates a command to find a DOM element based on the specified criteria.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|by| (\lstinline[style=pythonstyle]|SelectorType|): The type of selector to use (e.g., \lstinline[style=pythonstyle]|By.CSS_SELECTOR|, \lstinline[style=pythonstyle]|By.XPATH|).
    \item \lstinline[style=pythonstyle]|value| (\lstinline[style=pythonstyle]|str|): The selector value (e.g., CSS selector string, XPath expression).
    \item \lstinline[style=pythonstyle]|object_id| (\lstinline[style=pythonstyle]|str|, optional): The object ID of a parent element to search within. If empty, the search is performed on the entire document. Defaults to \lstinline[style=pythonstyle]|''|.
\end{itemize}

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|dict|: The command to be sent to the browser.
\end{itemize}

\paragraph{@classmethod find\_elements}

\begin{lstlisting}[style=pythonstyle]
@classmethod
def find_elements(cls, by: SelectorType, value: str, object_id: str = '') -> dict:
\end{lstlisting}

\noindent Generates a command to find multiple DOM elements based on the specified criteria.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|by| (\lstinline[style=pythonstyle]|SelectorType|): The type of selector to use (e.g., \lstinline[style=pythonstyle]|By.CSS_SELECTOR|, \lstinline[style=pythonstyle]|By.XPATH|).
    \item \lstinline[style=pythonstyle]|value| (\lstinline[style=pythonstyle]|str|): The selector value (e.g., CSS selector string, XPath expression).
    \item \lstinline[style=pythonstyle]|object_id| (\lstinline[style=pythonstyle]|str|, optional): The object ID of a parent element to search within. If empty, the search is performed on the entire document. Defaults to \lstinline[style=pythonstyle]|''|.
\end{itemize}

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|dict|: The command to be sent to the browser.
\end{itemize}

\subsubsection*{\texttt{pydoll.commands.fetch} Module}

\subsubsection*{\texttt{class pydoll.commands.fetch.FetchCommands}}
\noindent A collection of command templates for handling fetch events in the browser.

\noindent This class provides a structured way to create and manage commands related to fetch operations intercepted by the Fetch API\@. Each command corresponds to specific actions that can be performed on fetch requests, such as continuing a fetch request, fulfilling a fetch response, or handling authentication challenges.

\paragraph{Class Attributes}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|CONTINUE_REQUEST| (\lstinline[style=pythonstyle]|dict|): Template for continuing an intercepted fetch request.
    \item \lstinline[style=pythonstyle]|CONTINUE_REQUEST_WITH_AUTH| (\lstinline[style=pythonstyle]|dict|): Template for continuing a fetch request that requires authentication.
    \item \lstinline[style=pythonstyle]|DISABLE| (\lstinline[style=pythonstyle]|dict|): Template for disabling fetch interception.
    \item \lstinline[style=pythonstyle]|ENABLE| (\lstinline[style=pythonstyle]|dict|): Template for enabling fetch interception.
    \item \lstinline[style=pythonstyle]|FAIL_REQUEST| (\lstinline[style=pythonstyle]|dict|): Template for simulating a failure in a fetch request.
    \item \lstinline[style=pythonstyle]|FULFILL_REQUEST| (\lstinline[style=pythonstyle]|dict|): Template for fulfilling a fetch request with custom responses.
    \item \lstinline[style=pythonstyle]|GET_RESPONSE_BODY| (\lstinline[style=pythonstyle]|dict|): Template for retrieving the response body of a fetch request.
    \item \lstinline[style=pythonstyle]|CONTINUE_RESPONSE| (\lstinline[style=pythonstyle]|dict|): Template for continuing a fetch response for an intercepted request.
\end{itemize}

\paragraph{Class Methods}
\paragraph{@classmethod continue\_request}

\begin{lstlisting}[style=pythonstyle]
@classmethod
def continue_request(cls, request_id: str, url: str = '', method: str = '', post_data: str = '', headers: dict = {}, intercept_response: bool = False):
\end{lstlisting}

\noindent Creates a command to continue a paused fetch request.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|request_id| (\lstinline[style=pythonstyle]|str|): The ID of the fetch request to continue.
    \item \lstinline[style=pythonstyle]|url| (\lstinline[style=pythonstyle]|str|, optional): The new URL for the fetch request. Defaults to \lstinline[style=pythonstyle]|''|.
    \item \lstinline[style=pythonstyle]|method| (\lstinline[style=pythonstyle]|str|, optional): The HTTP method to use (e.g., \lstinline[style=pythonstyle]|`GET'|, \lstinline[style=pythonstyle]|`POST'|). Defaults to \lstinline[style=pythonstyle]|''|.
    \item \lstinline[style=pythonstyle]|post_data| (\lstinline[style=pythonstyle]|str|, optional): The body data to send with the fetch request. Defaults to \lstinline[style=pythonstyle]|''|.
    \item \lstinline[style=pythonstyle]|headers| (\lstinline[style=pythonstyle]|dict|, optional): A dictionary of HTTP headers to include in the fetch request. Defaults to \lstinline[style=pythonstyle]|{}|.
    \item \lstinline[style=pythonstyle]|intercept_response| (\lstinline[style=pythonstyle]|bool|, optional): Indicates if the response should be intercepted. Defaults to \lstinline[style=pythonstyle]|False|.
\end{itemize}

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|dict|: A command template for continuing the fetch request.
\end{itemize}

\paragraph{@classmethod continue\_request\_with\_auth}

\begin{lstlisting}[style=pythonstyle]
@classmethod
def continue_request_with_auth(cls, request_id: str, proxy_username: str, proxy_password: str):
\end{lstlisting}

\noindent Creates a command to continue a paused fetch request with authentication.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|request_id| (\lstinline[style=pythonstyle]|str|): The ID of the fetch request to continue.
    \item \lstinline[style=pythonstyle]|proxy_username| (\lstinline[style=pythonstyle]|str|): The username for proxy authentication.
    \item \lstinline[style=pythonstyle]|proxy_password| (\lstinline[style=pythonstyle]|str|): The password for proxy authentication.
\end{itemize}

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|dict|: A command template for continuing the fetch request with authentication.
\end{itemize}

\paragraph{@classmethod disable\_fetch\_events}

\begin{lstlisting}[style=pythonstyle]
@classmethod
def disable_fetch_events(cls):
\end{lstlisting}

\noindent Creates a command to disable fetch interception.

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|dict|: A command template for disabling fetch interception.
\end{itemize}

\paragraph{@classmethod enable\_fetch\_events}

\begin{lstlisting}[style=pythonstyle]
@classmethod
def enable_fetch_events(cls, handle_auth_requests: bool, resource_type: str):
\end{lstlisting}

\noindent Creates a command to enable fetch interception.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|handle_auth_requests| (\lstinline[style=pythonstyle]|bool|): Indicates if authentication requests should be handled.
    \item \lstinline[style=pythonstyle]|resource_type| (\lstinline[style=pythonstyle]|str|): The type of resource to intercept (e.g., \lstinline[style=pythonstyle]|`Document'|, \lstinline[style=pythonstyle]|`Image'|).
\end{itemize}

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|dict|: A command template for enabling fetch interception.
\end{itemize}

\paragraph{@classmethod fail\_request}

\begin{lstlisting}[style=pythonstyle]
@classmethod
def fail_request(cls, request_id: str, error_reason: str):
\end{lstlisting}

\noindent Creates a command to simulate a failure in a fetch request.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|request_id| (\lstinline[style=pythonstyle]|str|): The ID of the fetch request to fail.
    \item \lstinline[style=pythonstyle]|error_reason| (\lstinline[style=pythonstyle]|str|): A description of the failure reason.
\end{itemize}

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|dict|: A command template for failing the fetch request.
\end{itemize}

\paragraph{@classmethod fulfill\_request}

\begin{lstlisting}[style=pythonstyle]
@classmethod
def fulfill_request(cls, request_id: str, response_code: int, response_headers: dict = {}, binary_response_headers: str = '', body: str = '', response_phrase: str = ''):
\end{lstlisting}

\noindent Creates a command to fulfill a fetch request with a custom response.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|request_id| (\lstinline[style=pythonstyle]|str|): The ID of the fetch request to fulfill.
    \item \lstinline[style=pythonstyle]|response_code| (\lstinline[style=pythonstyle]|int|): The HTTP status code to return.
    \item \lstinline[style=pythonstyle]|response_headers| (\lstinline[style=pythonstyle]|dict|, optional): A dictionary of response headers. Defaults to \lstinline[style=pythonstyle]|{}|.
    \item \lstinline[style=pythonstyle]|binary_response_headers| (\lstinline[style=pythonstyle]|str|, optional): Binary response headers. Defaults to \lstinline[style=pythonstyle]|''|.
    \item \lstinline[style=pythonstyle]|body| (\lstinline[style=pythonstyle]|str|, optional): The body content of the response. Defaults to \lstinline[style=pythonstyle]|''|.
    \item \lstinline[style=pythonstyle]|response_phrase| (\lstinline[style=pythonstyle]|str|, optional): The response phrase (e.g., \lstinline[style=pythonstyle]|`OK'|, \lstinline[style=pythonstyle]|`Not Found'|). Defaults to \lstinline[style=pythonstyle]|''|.
\end{itemize}

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|dict|: A command template for fulfilling the fetch request.
\end{itemize}

\paragraph{@classmethod get\_response\_body}

\begin{lstlisting}[style=pythonstyle]
@classmethod
def get_response_body(cls, request_id: str):
\end{lstlisting}

\noindent Creates a command to retrieve the response body of a fetch request.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|request_id| (\lstinline[style=pythonstyle]|str|): The ID of the fetch request to retrieve the body from.
\end{itemize}

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|dict|: A command template for getting the response body.
\end{itemize}

\paragraph{@classmethod continue\_response}

\begin{lstlisting}[style=pythonstyle]
@classmethod
def continue_response(cls, request_id: str, response_code: int = '', response_headers: dict = {}, binary_response_headers: str = '', response_phrase: str = ''):
\end{lstlisting}

\noindent Creates a command to continue a fetch response for an intercepted request.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|request_id| (\lstinline[style=pythonstyle]|str|): The ID of the fetch request to continue the response for.
    \item \lstinline[style=pythonstyle]|response_code| (\lstinline[style=pythonstyle]|int|, optional): The HTTP status code to send. Defaults to \lstinline[style=pythonstyle]|''|.
    \item \lstinline[style=pythonstyle]|response_headers| (\lstinline[style=pythonstyle]|dict|, optional): A dictionary of response headers. Defaults to \lstinline[style=pythonstyle]|{}|.
    \item \lstinline[style=pythonstyle]|binary_response_headers| (\lstinline[style=pythonstyle]|str|, optional): Binary response headers. Defaults to \lstinline[style=pythonstyle]|''|.
    \item \lstinline[style=pythonstyle]|response_phrase| (\lstinline[style=pythonstyle]|str|, optional): The response phrase (e.g., \lstinline[style=pythonstyle]|`OK'|). Defaults to \lstinline[style=pythonstyle]|''|.
\end{itemize}

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|dict|: A command template for continuing the fetch response.
\end{itemize}

\subsubsection*{\texttt{pydoll.commands.input} Module}

\subsubsection*{\texttt{class pydoll.commands.input.InputCommands}}
\noindent A class to define input commands for simulating user interactions with the browser using the Chrome DevTools Protocol (CDP). The commands allow for simulating mouse clicks and keyboard presses.

\paragraph{Class Attributes}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|CLICK_ELEMENT_TEMPLATE| (\lstinline[style=pythonstyle]|dict|): Template for dispatching a mouse event (click).
    \item \lstinline[style=pythonstyle]|KEY_PRESS_TEMPLATE| (\lstinline[style=pythonstyle]|dict|): Template for dispatching a key event (press).
    \item \lstinline[style=pythonstyle]|INSERT_TEXT_TEMPLATE| (\lstinline[style=pythonstyle]|dict|): Template for inserting text into an input field.
\end{itemize}

\paragraph{Class Methods}
\paragraph{@classmethod mouse\_press}

\begin{lstlisting}[style=pythonstyle]
@classmethod
def mouse_press(cls, x: int, y: int) -> dict:
\end{lstlisting}

\noindent Generates the command to simulate pressing the mouse button on a specific location.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|x| (\lstinline[style=pythonstyle]|int|): The x-coordinate of the mouse press.
    \item \lstinline[style=pythonstyle]|y| (\lstinline[style=pythonstyle]|int|): The y-coordinate of the mouse press.
\end{itemize}

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|dict|: The command to be sent to the browser.
\end{itemize}

\paragraph{@classmethod mouse\_release}

\begin{lstlisting}[style=pythonstyle]
@classmethod
def mouse_release(cls, x: int, y: int) -> dict:
\end{lstlisting}

\noindent Generates the command to simulate releasing the mouse button.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|x| (\lstinline[style=pythonstyle]|int|): The x-coordinate of the mouse release.
    \item \lstinline[style=pythonstyle]|y| (\lstinline[style=pythonstyle]|int|): The y-coordinate of the mouse release.
\end{itemize}

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|dict|: The command to be sent to the browser.
\end{itemize}

\paragraph{@classmethod key\_press}

\begin{lstlisting}[style=pythonstyle]
@classmethod
def key_press(cls, char: str) -> dict:
\end{lstlisting}

\noindent Generates the command to simulate pressing a key on the keyboard.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|char| (\lstinline[style=pythonstyle]|str|): The character to be pressed.
\end{itemize}

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|dict|: The command to be sent to the browser.
\end{itemize}

\paragraph{@classmethod insert\_text}

\begin{lstlisting}[style=pythonstyle]
@classmethod
def insert_text(cls, text: str) -> dict:
\end{lstlisting}

\noindent Generates the command to insert text into an input field.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|text| (\lstinline[style=pythonstyle]|str|): The text to be inserted.
\end{itemize}

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|dict|: The command to be sent to the browser.
\end{itemize}

\subsubsection*{\texttt{pydoll.commands.network} Module}

\subsubsection*{\texttt{class pydoll.commands.network.NetworkCommands}}
\noindent This class encapsulates the network commands of the Chrome DevTools Protocol (CDP). CDP allows developers to interact with the Chrome browser's internal mechanisms to inspect, manipulate, and monitor network operations, which can be invaluable for debugging web applications, testing network behaviors, and optimizing performance.

\paragraph{Class Attributes}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|CLEAR_BROWSER_CACHE| (\lstinline[style=pythonstyle]|dict|): Command template to clear browser cache.
    \item \lstinline[style=pythonstyle]|CLEAR_BROWSER_COOKIES| (\lstinline[style=pythonstyle]|dict|): Command template to clear browser cookies.
    \item \lstinline[style=pythonstyle]|DELETE_COOKIES_TEMPLATE| (\lstinline[style=pythonstyle]|dict|): Template for deleting specific cookies.
    \item \lstinline[style=pythonstyle]|DISABLE| (\lstinline[style=pythonstyle]|dict|): Command template to disable network events.
    \item \lstinline[style=pythonstyle]|ENABLE| (\lstinline[style=pythonstyle]|dict|): Command template to enable network events.
    \item \lstinline[style=pythonstyle]|GET_COOKIES_TEMPLATE| (\lstinline[style=pythonstyle]|dict|): Template for getting cookies.
    \item \lstinline[style=pythonstyle]|GET_REQUEST_POST_DATA_TEMPLATE| (\lstinline[style=pythonstyle]|dict|): Template for getting request POST data.
    \item \lstinline[style=pythonstyle]|GET_RESPONSE_BODY_TEMPLATE| (\lstinline[style=pythonstyle]|dict|): Template for getting response body.
    \item \lstinline[style=pythonstyle]|SET_CACHE_DISABLED_TEMPLATE| (\lstinline[style=pythonstyle]|dict|): Template for setting cache disabled state.
    \item \lstinline[style=pythonstyle]|SET_COOKIE_TEMPLATE| (\lstinline[style=pythonstyle]|dict|): Template for setting a cookie.
    \item \lstinline[style=pythonstyle]|SET_COOKIES_TEMPLATE| (\lstinline[style=pythonstyle]|dict|): Template for setting multiple cookies.
    \item \lstinline[style=pythonstyle]|SET_EXTRA_HTTP_HEADERS_TEMPLATE| (\lstinline[style=pythonstyle]|dict|): Template for setting extra HTTP headers.
    \item \lstinline[style=pythonstyle]|SET_USERAGENT_OVERRIDE_TEMPLATE| (\lstinline[style=pythonstyle]|dict|): Template for setting user agent override.
    \item \lstinline[style=pythonstyle]|GET_ALL_COOKIES| (\lstinline[style=pythonstyle]|dict|): Command template to get all cookies.
    \item \lstinline[style=pythonstyle]|SEARCH_IN_RESPONSE_TEMPLATE| (\lstinline[style=pythonstyle]|dict|): Template for searching in response body.
    \item \lstinline[style=pythonstyle]|SET_BLOCKED_URLS| (\lstinline[style=pythonstyle]|dict|): Template for setting blocked URLs.
\end{itemize}

\paragraph{Class Methods}
\paragraph{@classmethod clear\_browser\_cache}

\begin{lstlisting}[style=pythonstyle]
@classmethod
def clear_browser_cache(cls):
\end{lstlisting}

\noindent Command to clear the browser's cache.

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|dict|: The command to be sent to the browser.
\end{itemize}

\paragraph{@classmethod clear\_browser\_cookies}

\begin{lstlisting}[style=pythonstyle]
@classmethod
def clear_browser_cookies(cls):
\end{lstlisting}

\noindent Command to clear all cookies stored in the browser.

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|dict|: The command to be sent to the browser.
\end{itemize}

\paragraph{@classmethod delete\_cookies}

\begin{lstlisting}[style=pythonstyle]
@classmethod
def delete_cookies(cls, name: str, url: str = ''):
\end{lstlisting}

\noindent Creates a command to delete a specific cookie by name.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|name| (\lstinline[style=pythonstyle]|str|): The name of the cookie to delete.
    \item \lstinline[style=pythonstyle]|url| (\lstinline[style=pythonstyle]|str|, optional): The URL associated with the cookie. If specified, only the cookie matching both the name and URL will be deleted.
\end{itemize}

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|dict|: The command to be sent to the browser.
\end{itemize}

\paragraph{@classmethod disable\_network\_events}

\begin{lstlisting}[style=pythonstyle]
@classmethod
def disable_network_events(cls):
\end{lstlisting}

\noindent Command to disable network event notifications.

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|dict|: The command to be sent to the browser.
\end{itemize}

\paragraph{@classmethod enable\_network\_events}

\begin{lstlisting}[style=pythonstyle]
@classmethod
def enable_network_events(cls):
\end{lstlisting}

\noindent Command to enable network event notifications.

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|dict|: The command to be sent to the browser.
\end{itemize}

\paragraph{@classmethod get\_cookies}

\begin{lstlisting}[style=pythonstyle]
@classmethod
def get_cookies(cls, urls: list[str] = []):
\end{lstlisting}

\noindent Creates a command to retrieve cookies from specified URLs.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|urls| (\lstinline[style=pythonstyle]|list[str]|, optional): A list of URLs for which to retrieve cookies. If not provided, cookies from all URLs will be fetched.
\end{itemize}

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|dict|: The command to be sent to the browser.
\end{itemize}

\paragraph{@classmethod get\_request\_post\_data}

\begin{lstlisting}[style=pythonstyle]
@classmethod
def get_request_post_data(cls, request_id: str):
\end{lstlisting}

\noindent Creates a command to retrieve POST data associated with a specific request.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|request_id| (\lstinline[style=pythonstyle]|str|): The unique identifier of the network request whose POST data is to be retrieved.
\end{itemize}

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|dict|: The command to be sent to the browser.
\end{itemize}

\paragraph{@classmethod get\_response\_body}

\begin{lstlisting}[style=pythonstyle]
@classmethod
def get_response_body(cls, request_id: str):
\end{lstlisting}

\noindent Creates a command to retrieve the body of a response for a specific request.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|request_id| (\lstinline[style=pythonstyle]|str|): The unique identifier of the request for which the response body is to be fetched.
\end{itemize}

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|dict|: The command to be sent to the browser.
\end{itemize}

\paragraph{@classmethod set\_cache\_disabled}

\begin{lstlisting}[style=pythonstyle]
@classmethod
def set_cache_disabled(cls, cache_disabled: bool):
\end{lstlisting}

\noindent Creates a command to enable or disable the browser cache.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|cache_disabled| (\lstinline[style=pythonstyle]|bool|): Set to \lstinline[style=pythonstyle]|True| to disable caching, or \lstinline[style=pythonstyle]|False| to enable it.
\end{itemize}

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|dict|: The command to be sent to the browser.
\end{itemize}

\paragraph{@classmethod set\_cookie}

\begin{lstlisting}[style=pythonstyle]
@classmethod
def set_cookie(cls, name: str, value: str, url: str = ''):
\end{lstlisting}

\noindent Creates a command to set a specific cookie.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|name| (\lstinline[style=pythonstyle]|str|): The name of the cookie.
    \item \lstinline[style=pythonstyle]|value| (\lstinline[style=pythonstyle]|str|): The value of the cookie.
    \item \lstinline[style=pythonstyle]|url| (\lstinline[style=pythonstyle]|str|, optional): The URL associated with the cookie. If provided, the cookie will be valid for this URL only.
\end{itemize}

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|dict|: The command to be sent to the browser.
\end{itemize}

\paragraph{@classmethod set\_cookies}

\begin{lstlisting}[style=pythonstyle]
@classmethod
def set_cookies(cls, cookies: list[dict]):
\end{lstlisting}

\noindent Creates a command to set multiple cookies at once.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|cookies| (\lstinline[style=pythonstyle]|list[dict]|): A list of dictionaries, each representing a cookie with its properties (name, value, url, etc.).
\end{itemize}

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|dict|: The command to be sent to the browser.
\end{itemize}

\paragraph{@classmethod set\_extra\_http\_headers}

\begin{lstlisting}[style=pythonstyle]
@classmethod
def set_extra_http_headers(cls, headers: dict):
\end{lstlisting}

\noindent Creates a command to set additional HTTP headers for subsequent network requests.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|headers| (\lstinline[style=pythonstyle]|dict|): A dictionary of headers to include in all future requests.
\end{itemize}

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|dict|: The command to be sent to the browser.
\end{itemize}

\paragraph{@classmethod set\_useragent\_override}

\begin{lstlisting}[style=pythonstyle]
@classmethod
def set_useragent_override(cls, user_agent: str):
\end{lstlisting}

\noindent Creates a command to override the user agent string used in network requests.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|user_agent| (\lstinline[style=pythonstyle]|str|): The user agent string to set for future network requests.
\end{itemize}

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|dict|: The command to be sent to the browser.
\end{itemize}

\paragraph{@classmethod get\_all\_cookies}

\begin{lstlisting}[style=pythonstyle]
@classmethod
def get_all_cookies(cls):
\end{lstlisting}

\noindent Command to retrieve all cookies stored in the browser.

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|dict|: The command to be sent to the browser.
\end{itemize}

\paragraph{@classmethod search\_in\_response}

\begin{lstlisting}[style=pythonstyle]
@classmethod
def search_in_response(cls, request_id: str, query: str, case_sensitive: bool = False, is_regex: bool = False):
\end{lstlisting}

\noindent Creates a command to search for a specific query in the response body of a network request.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|request_id| (\lstinline[style=pythonstyle]|str|): The unique identifier of the request to search within.
    \item \lstinline[style=pythonstyle]|query| (\lstinline[style=pythonstyle]|str|): The string to search for within the response body.
    \item \lstinline[style=pythonstyle]|case_sensitive| (\lstinline[style=pythonstyle]|bool|, optional): Whether the search should be case sensitive. Defaults to \lstinline[style=pythonstyle]|False|.
    \item \lstinline[style=pythonstyle]|is_regex| (\lstinline[style=pythonstyle]|bool|, optional): Whether the query should be treated as a regular expression. Defaults to \lstinline[style=pythonstyle]|False|.
\end{itemize}

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|dict|: The command to be sent to the browser.
\end{itemize}

\paragraph{@classmethod set\_blocked\_urls}

\begin{lstlisting}[style=pythonstyle]
@classmethod
def set_blocked_urls(cls, urls: list[str]):
\end{lstlisting}

\noindent Creates a command to block specific URLs from being requested by the browser.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|urls| (\lstinline[style=pythonstyle]|list[str]|): A list of URL patterns to block. The browser will not make requests to any URLs matching these patterns.
\end{itemize}

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|dict|: The command to be sent to the browser.
\end{itemize}

\subsubsection*{\texttt{pydoll.commands.page} Module}

\subsubsection*{\texttt{class pydoll.commands.page.PageCommands}}
\noindent PageCommands class provides a set of commands to interact with the Page domain of the Chrome DevTools Protocol (CDP). These commands enable users to perform operations related to web pages, such as capturing screenshots, navigating to URLs, refreshing pages, printing to PDF, and enabling the Page domain.

\paragraph{Class Attributes}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|SCREENSHOT_TEMPLATE| (\lstinline[style=pythonstyle]|dict|): Template for capturing a screenshot.
    \item \lstinline[style=pythonstyle]|GO_TO_TEMPLATE| (\lstinline[style=pythonstyle]|dict|): Template for navigating to a URL.
    \item \lstinline[style=pythonstyle]|REFRESH_TEMPLATE| (\lstinline[style=pythonstyle]|dict|): Template for refreshing the page.
    \item \lstinline[style=pythonstyle]|PRINT_TO_PDF_TEMPLATE| (\lstinline[style=pythonstyle]|dict|): Template for printing to PDF.
    \item \lstinline[style=pythonstyle]|ENABLE_PAGE| (\lstinline[style=pythonstyle]|dict|): Command template to enable Page domain events.
    \item \lstinline[style=pythonstyle]|DISABLE_PAGE| (\lstinline[style=pythonstyle]|dict|): Command template to disable Page domain events.
    \item \lstinline[style=pythonstyle]|SET_DOWNLOAD_BEHAVIOR| (\lstinline[style=pythonstyle]|dict|): Template for setting download behavior on page level.
    \item \lstinline[style=pythonstyle]|HANDLE_DIALOG| (\lstinline[style=pythonstyle]|dict|): Template for handling JavaScript dialogs.
    \item \lstinline[style=pythonstyle]|CLOSE| (\lstinline[style=pythonstyle]|dict|): Command template to close the page.
\end{itemize}

\paragraph{Class Methods}
\paragraph{@classmethod handle\_dialog}

\begin{lstlisting}[style=pythonstyle]
@classmethod
def handle_dialog(cls, accept: bool = True) -> dict:
\end{lstlisting}

\noindent Generates the command to handle a JavaScript dialog.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|accept| (\lstinline[style=pythonstyle]|bool|, optional): Whether to accept the dialog. If \lstinline[style=pythonstyle]|True|, the dialog will be accepted. If \lstinline[style=pythonstyle]|False|, the dialog will be dismissed. Defaults to \lstinline[style=pythonstyle]|True|.
\end{itemize}

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|dict|: The command to be sent to the browser.
\end{itemize}

\paragraph{@classmethod set\_download\_path}

\begin{lstlisting}[style=pythonstyle]
@classmethod
def set_download_path(cls, path: str) -> dict:
\end{lstlisting}

\noindent Generates the command to set the download path for the browser at the page level.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|path| (\lstinline[style=pythonstyle]|str|): The path where the downloaded files should be saved.
\end{itemize}

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|dict|: The command to be sent to the browser.
\end{itemize}

\paragraph{@classmethod screenshot}

\begin{lstlisting}[style=pythonstyle]
@classmethod
def screenshot(cls, fmt: str = 'jpeg', quality: int = 100, clip: dict = None) -> dict:
\end{lstlisting}

\noindent Generates the command to capture a screenshot of the current page.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|fmt| (\lstinline[style=pythonstyle]|str|, optional): The format of the image to be captured. Can be \lstinline[style=pythonstyle]|`png'| or \lstinline[style=pythonstyle]|`jpeg'|. Defaults to \lstinline[style=pythonstyle]|'jpeg'|.
    \item \lstinline[style=pythonstyle]|quality| (\lstinline[style=pythonstyle]|int|, optional): The quality of the image to be captured, applicable only if the format is \lstinline[style=pythonstyle]|`jpeg'|. Value should be between 0 (lowest quality) and 100 (highest quality). Defaults to \lstinline[style=pythonstyle]|100|.
    \item \lstinline[style=pythonstyle]|clip| (\lstinline[style=pythonstyle]|dict|, optional): A dictionary defining the clipping region for the screenshot. It should contain keys \lstinline[style=pythonstyle]|`x'|, \lstinline[style=pythonstyle]|`y'|, \lstinline[style=pythonstyle]|`width'|, \lstinline[style=pythonstyle]|`height'|, and \lstinline[style=pythonstyle]|`scale'|. Defaults to \lstinline[style=pythonstyle]|None|.
\end{itemize}

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|dict|: The command to be sent to the browser.
\end{itemize}

\paragraph{@classmethod go\_to}

\begin{lstlisting}[style=pythonstyle]
@classmethod
def go_to(cls, url: str) -> dict:
\end{lstlisting}

\noindent Generates the command to navigate to a specific URL.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|url| (\lstinline[style=pythonstyle]|str|): The URL to navigate to. It should be a valid URL format.
\end{itemize}

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|dict|: The command to be sent to the browser.
\end{itemize}

\paragraph{@classmethod refresh}

\begin{lstlisting}[style=pythonstyle]
@classmethod
def refresh(cls, ignore_cache: bool = False) -> dict:
\end{lstlisting}

\noindent Generates the command to refresh the current page.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|ignore_cache| (\lstinline[style=pythonstyle]|bool|, optional): Whether to ignore the cache when refreshing. If \lstinline[style=pythonstyle]|True|, the cached resources will not be used. Defaults to \lstinline[style=pythonstyle]|False|.
\end{itemize}

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|dict|: The command to be sent to the browser.
\end{itemize}

\paragraph{@classmethod print\_to\_pdf}

\begin{lstlisting}[style=pythonstyle]
@classmethod
def print_to_pdf(cls, scale: int = 1, paper_width: float = 8.5, paper_height: float = 11) -> dict:
\end{lstlisting}

\noindent Generates the command to print the current page to a PDF.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|scale| (\lstinline[style=pythonstyle]|int|, optional): The scale of the page to print. Default is 1 (100\%). Defaults to \lstinline[style=pythonstyle]|1|.
    \item \lstinline[style=pythonstyle]|paper_width| (\lstinline[style=pythonstyle]|float|, optional): The width of the paper to print on, in inches. Default is 8.5 inches. Defaults to \lstinline[style=pythonstyle]|8.5|.
    \item \lstinline[style=pythonstyle]|paper_height| (\lstinline[style=pythonstyle]|float|, optional): The height of the paper to print on, in inches. Default is 11 inches. Defaults to \lstinline[style=pythonstyle]|11|.
\end{itemize}

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|dict|: The command to be sent to the browser.
\end{itemize}

\paragraph{@classmethod enable\_page}

\begin{lstlisting}[style=pythonstyle]
@classmethod
def enable_page(cls) -> dict:
\end{lstlisting}

\noindent Generates the command to enable the Page domain.

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|dict|: The command to be sent to the browser.
\end{itemize}

\paragraph{@classmethod disable\_page}

\begin{lstlisting}[style=pythonstyle]
@classmethod
def disable_page(cls) -> dict:
\end{lstlisting}

\noindent Generates the command to disable the Page domain.

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|dict|: The command to be sent to the browser.
\end{itemize}

\paragraph{@classmethod close}

\begin{lstlisting}[style=pythonstyle]
@classmethod
def close(cls) -> dict:
\end{lstlisting}

\noindent Generates the command to close the current page.

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|dict|: The command to be sent to the browser.
\end{itemize}

\subsubsection*{\texttt{pydoll.commands.runtime} Module}

\subsubsection*{\texttt{class pydoll.commands.runtime.RuntimeCommands}}

\paragraph{Class Attributes}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|EVALUATE_TEMPLATE| (\lstinline[style=pythonstyle]|dict|): Template for evaluating JavaScript code.
    \item \lstinline[style=pythonstyle]|CALL_FUNCTION_ON_TEMPLATE| (\lstinline[style=pythonstyle]|dict|): Template for calling a function on a specific object.
    \item \lstinline[style=pythonstyle]|GET_PROPERTIES| (\lstinline[style=pythonstyle]|dict|): Template for getting properties of an object.
\end{itemize}

\paragraph{Class Methods}
\paragraph{@classmethod get\_properties}

\begin{lstlisting}[style=pythonstyle]
@classmethod
def get_properties(cls, object_id: str) -> dict:
\end{lstlisting}

\noindent Generates the command to get the properties of a specific object.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|object_id| (\lstinline[style=pythonstyle]|str|): The object ID.
\end{itemize}

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|dict|: The command to be sent to the browser.
\end{itemize}

\paragraph{@classmethod call\_function\_on}

\begin{lstlisting}[style=pythonstyle]
@classmethod
def call_function_on(cls, object_id: str, function_declaration: str, return_by_value: bool = False) -> dict:
\end{lstlisting}

\noindent Generates the command to call a function on a specific object.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|object_id| (\lstinline[style=pythonstyle]|str|): The object ID.
    \item \lstinline[style=pythonstyle]|function_declaration| (\lstinline[style=pythonstyle]|str|): The JavaScript function declaration as a string.
    \item \lstinline[style=pythonstyle]|return_by_value| (\lstinline[style=pythonstyle]|bool|, optional): Whether to return the result by value. Defaults to \lstinline[style=pythonstyle]|False|.
\end{itemize}

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|dict|: The command to be sent to the browser.
\end{itemize}

\paragraph{@classmethod evaluate\_script}

\begin{lstlisting}[style=pythonstyle]
@classmethod
def evaluate_script(cls, expression: str) -> dict:
\end{lstlisting}

\noindent Generates the command to evaluate JavaScript code.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|expression| (\lstinline[style=pythonstyle]|str|): The JavaScript expression to evaluate.
\end{itemize}

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|dict|: The command to be sent to the browser.
\end{itemize}

\subsubsection*{\texttt{pydoll.commands.storage} Module}

\subsubsection*{\texttt{class pydoll.commands.storage.StorageCommands}}

\paragraph{Class Attributes}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|CLEAR_COOKIES| (\lstinline[style=pythonstyle]|dict|): Command template to clear all cookies.
    \item \lstinline[style=pythonstyle]|SET_COOKIES| (\lstinline[style=pythonstyle]|dict|): Command template to set multiple cookies.
    \item \lstinline[style=pythonstyle]|GET_COOKIES| (\lstinline[style=pythonstyle]|dict|): Command template to get cookies.
\end{itemize}

\paragraph{Class Methods}
\paragraph{@classmethod clear\_cookies}

\begin{lstlisting}[style=pythonstyle]
@classmethod
def clear_cookies(cls) -> dict:
\end{lstlisting}

\noindent Generates the command to clear all cookies.

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|dict|: The command to be sent to the browser.
\end{itemize}

\paragraph{@classmethod set\_cookies}

\begin{lstlisting}[style=pythonstyle]
@classmethod
def set_cookies(cls, cookies: list) -> dict:
\end{lstlisting}

\noindent Generates the command to set multiple cookies.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|cookies| (\lstinline[style=pythonstyle]|list|): A list of cookie dictionaries.
\end{itemize}

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|dict|: The command to be sent to the browser.
\end{itemize}

\paragraph{@classmethod get\_cookies}

\begin{lstlisting}[style=pythonstyle]
@classmethod
def get_cookies(cls) -> dict:
\end{lstlisting}

\noindent Generates the command to get cookies.

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|dict|: The command to be sent to the browser.
\end{itemize}

\subsubsection*{\texttt{pydoll.commands.target} Module}

\subsubsection*{\texttt{class pydoll.commands.target.TargetCommands}}

\paragraph{Class Attributes}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|ACTIVATE_TARGET| (\lstinline[style=pythonstyle]|dict|): Command template to activate a target.
    \item \lstinline[style=pythonstyle]|ATTACH_TO_TARGET| (\lstinline[style=pythonstyle]|dict|): Command template to attach to a target.
    \item \lstinline[style=pythonstyle]|CLOSE_TARGET| (\lstinline[style=pythonstyle]|dict|): Command template to close a target.
    \item \lstinline[style=pythonstyle]|CREATE_TARGET| (\lstinline[style=pythonstyle]|dict|): Command template to create a new target (page/tab).
    \item \lstinline[style=pythonstyle]|GET_TARGETS| (\lstinline[style=pythonstyle]|dict|): Command template to get all targets.
    \item \lstinline[style=pythonstyle]|GET_TARGET_INFO| (\lstinline[style=pythonstyle]|dict|): Command template to get target information.
\end{itemize}

\paragraph{Class Methods}
\paragraph{@classmethod activate\_target}

\begin{lstlisting}[style=pythonstyle]
@classmethod
def activate_target(cls, target_id: str) -> dict:
\end{lstlisting}

\noindent Generates the command to activate a target.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|target_id| (\lstinline[style=pythonstyle]|str|): The target ID.
\end{itemize}

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|dict|: The command to be sent to the browser.
\end{itemize}

\paragraph{@classmethod attach\_to\_target}

\begin{lstlisting}[style=pythonstyle]
@classmethod
def attach_to_target(cls, target_id: str) -> dict:
\end{lstlisting}

\noindent Generates the command to attach to a target.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|target_id| (\lstinline[style=pythonstyle]|str|): The target ID.
\end{itemize}

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|dict|: The command to be sent to the browser.
\end{itemize}

\paragraph{@classmethod close\_target}

\begin{lstlisting}[style=pythonstyle]
@classmethod
def close_target(cls, target_id: str) -> dict:
\end{lstlisting}

\noindent Generates the command to close a target.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|target_id| (\lstinline[style=pythonstyle]|str|): The target ID.
\end{itemize}

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|dict|: The command to be sent to the browser.
\end{itemize}

\paragraph{@classmethod create\_target}

\begin{lstlisting}[style=pythonstyle]
@classmethod
def create_target(cls, url: str) -> dict:
\end{lstlisting}

\noindent Generates the command to create a new target (page/tab).

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|url| (\lstinline[style=pythonstyle]|str|): The URL to open in the new target.
\end{itemize}

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|dict|: The command to be sent to the browser.
\end{itemize}

\paragraph{@classmethod get\_targets}

\begin{lstlisting}[style=pythonstyle]
@classmethod
def get_targets(cls) -> dict:
\end{lstlisting}

\noindent Generates the command to get all targets.

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|dict|: The command to be sent to the browser.
\end{itemize}

\hrulefill

\subsection*{\texttt{pydoll.connection} Module}

\subsubsection*{\texttt{class pydoll.connection.connection.ConnectionHandler}}
\noindent\texttt{class ConnectionHandler()}

\noindent A class to handle WebSocket connections for browser automation.

\noindent This class manages the connection to the browser and the associated page, providing methods to execute commands and register event callbacks.

\paragraph{Constructor}

\begin{lstlisting}[style=pythonstyle]
def __init__(self, connection_port: int, page_id: str = 'browser', ws_address_resolver: Callable[[int], str] = get_browser_ws_address, ws_connector: Callable = websockets.connect):
\end{lstlisting}

\noindent Initializes the ConnectionHandler instance.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|connection_port| (\lstinline[style=pythonstyle]|int|): The port to connect to the browser.
    \item \lstinline[style=pythonstyle]|page_id| (\lstinline[style=pythonstyle]|str|, optional): The page ID\@. Defaults to \lstinline[style=pythonstyle]|'browser'| for browser-level connection.
    \item \lstinline[style=pythonstyle]|ws_address_resolver| (\lstinline[style=pythonstyle]|Callable[[int], str]|, optional): A function to resolve the WebSocket address. Defaults to \lstinline[style=pythonstyle]|get_browser_ws_address|.
    \item \lstinline[style=pythonstyle]|ws_connector| (\lstinline[style=pythonstyle]|Callable|, optional): A function to establish the WebSocket connection. Defaults to \lstinline[style=pythonstyle]|websockets.connect|.
\end{itemize}

\paragraph{Properties}
\paragraph{network\_logs}

\begin{lstlisting}[style=pythonstyle]
network_logs: list
\end{lstlisting}

\noindent Returns the list of network logs received through this connection.

\paragraph{dialog}

\begin{lstlisting}[style=pythonstyle]
dialog: dict
\end{lstlisting}

\noindent Returns the current dialog information, if a JavaScript dialog is open.

\paragraph{Methods}
\paragraph{async def ping}

\begin{lstlisting}[style=pythonstyle]
async def ping(self) -> bool:
\end{lstlisting}

\noindent Sends a ping message to the browser to check the connection.

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|bool|: \lstinline[style=pythonstyle]|True| if the ping was successful, \lstinline[style=pythonstyle]|False| otherwise.
\end{itemize}

\paragraph{async def execute\_command}

\begin{lstlisting}[style=pythonstyle]
async def execute_command(self, command: dict, timeout: int = 10) -> dict:
\end{lstlisting}

\noindent Sends a command to the browser and awaits its response.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|command| (\lstinline[style=pythonstyle]|dict|): The command to send, structured as a dictionary.
    \item \lstinline[style=pythonstyle]|timeout| (\lstinline[style=pythonstyle]|int|, optional): Time in seconds to wait for a response. Defaults to \lstinline[style=pythonstyle]|10|.
\end{itemize}

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|dict|: The response from the browser.
\end{itemize}

\paragraph{Raises}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|InvalidCommand|: If the command is not a dictionary.
    \item \lstinline[style=pythonstyle]|TimeoutError|: If the command execution exceeds the timeout.
    \item \lstinline[style=pythonstyle]|websockets.ConnectionClosed|: If the WebSocket connection is closed unexpectedly.
\end{itemize}

\paragraph{async def register\_callback}

\begin{lstlisting}[style=pythonstyle]
async def register_callback(self, event_name: str, callback: Callable, temporary: bool = False) -> int:
\end{lstlisting}

\noindent Registers a callback function to be executed when a specific event occurs.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|event_name| (\lstinline[style=pythonstyle]|str|): The name of the event to listen for (e.g., \lstinline[style=pythonstyle]|`Page.loadEventFired'|).
    \item \lstinline[style=pythonstyle]|callback| (\lstinline[style=pythonstyle]|Callable|): The asynchronous or synchronous function to call when the event is received.
    \item \lstinline[style=pythonstyle]|temporary| (\lstinline[style=pythonstyle]|bool|, optional): If \lstinline[style=pythonstyle]|True|, the callback will be removed after it is triggered once. Defaults to \lstinline[style=pythonstyle]|False|.
\end{itemize}

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|int|: The ID of the registered callback.
\end{itemize}

\paragraph{async def remove\_callback}

\begin{lstlisting}[style=pythonstyle]
async def remove_callback(self, callback_id: int) -> bool:
\end{lstlisting}

\noindent Removes a registered callback by its ID.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|callback_id| (\lstinline[style=pythonstyle]|int|): The ID of the callback to remove.
\end{itemize}

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|bool|: \lstinline[style=pythonstyle]|True| if the callback was successfully removed, \lstinline[style=pythonstyle]|False| if the ID was not found.
\end{itemize}

\paragraph{async def clear\_callbacks}

\begin{lstlisting}[style=pythonstyle]
async def clear_callbacks(self):
\end{lstlisting}

\noindent Clears all registered event callbacks.

\paragraph{async def close}

\begin{lstlisting}[style=pythonstyle]
async def close(self):
\end{lstlisting}

\noindent Closes the WebSocket connection and clears all event callbacks.

\paragraph{Asynchronous Context Manager Methods}
\paragraph{async def \_\_aenter\_\_}

\begin{lstlisting}[style=pythonstyle]
async def __aenter__(self):
\end{lstlisting}

\noindent Enters the asynchronous context. Returns the \lstinline[style=pythonstyle]|ConnectionHandler| instance.

\paragraph{async def \_\_aexit\_\_}

\begin{lstlisting}[style=pythonstyle]
async def __aexit__(self, exc_type, exc_val, exc_tb):
\end{lstlisting}

\noindent Exits the asynchronous context. Automatically closes the connection.

\subsubsection*{\texttt{class pydoll.connection.managers.CommandManager}}
\noindent Manages pending commands and their futures.

\paragraph{Methods}
\paragraph{create\_command\_future}

\begin{lstlisting}[style=pythonstyle]
def create_command_future(self, command: dict) -> asyncio.Future:
\end{lstlisting}

\noindent Creates a future for a command and stores it, associating it with a command ID.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|command| (\lstinline[style=pythonstyle]|dict|): The command dictionary (will be assigned an \lstinline[style=pythonstyle]|`id'| in this method).
\end{itemize}

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|asyncio.Future|: The future object that will be resolved when the response for this command is received.
\end{itemize}

\paragraph{resolve\_command}

\begin{lstlisting}[style=pythonstyle]
def resolve_command(self, response_id: int, result: str):
\end{lstlisting}

\noindent Resolves a pending command's future with the received result, based on the response ID.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|response_id| (\lstinline[style=pythonstyle]|int|): The ID of the command response.
    \item \lstinline[style=pythonstyle]|result| (\lstinline[style=pythonstyle]|str|): The JSON string response from the browser.
\end{itemize}

\paragraph{remove\_pending\_command}

\begin{lstlisting}[style=pythonstyle]
def remove_pending_command(self, command_id: int):
\end{lstlisting}

\noindent Removes a pending command without resolving it (useful for timeouts).

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|command_id| (\lstinline[style=pythonstyle]|int|): ID of the command to be removed.
\end{itemize}

\subsubsection*{\texttt{class pydoll.connection.managers.EventsHandler}}
\noindent Manages event callbacks, processes events, and maintains network logs.

\paragraph{Properties}
\paragraph{network\_logs}

\begin{lstlisting}[style=pythonstyle]
network_logs: list
\end{lstlisting}

\noindent Returns the list of network logs.

\paragraph{dialog}

\begin{lstlisting}[style=pythonstyle]
dialog: dict
\end{lstlisting}

\noindent Returns the dialog information.

\paragraph{Methods}
\paragraph{register\_callback}

\begin{lstlisting}[style=pythonstyle]
def register_callback(self, event_name: str, callback: Callable, temporary: bool = False) -> int:
\end{lstlisting}

\noindent Registers a callback for a specific event type.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|event_name| (\lstinline[style=pythonstyle]|str|): The name of the event to listen for.
    \item \lstinline[style=pythonstyle]|callback| (\lstinline[style=pythonstyle]|Callable|): The callback function to register.
    \item \lstinline[style=pythonstyle]|temporary| (\lstinline[style=pythonstyle]|bool|, optional): Whether the callback is temporary (removed after first trigger). Defaults to \lstinline[style=pythonstyle]|False|.
\end{itemize}

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|int|: ID of the registered callback.
\end{itemize}

\paragraph{Raises}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|InvalidCallback|: If the callback is not callable.
\end{itemize}

\paragraph{remove\_callback}

\begin{lstlisting}[style=pythonstyle]
def remove_callback(self, callback_id: int) -> bool:
\end{lstlisting}

\noindent Removes a callback by its ID.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|callback_id| (\lstinline[style=pythonstyle]|int|): ID of the callback to remove.
\end{itemize}

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|bool|: \lstinline[style=pythonstyle]|True| if callback was removed, \lstinline[style=pythonstyle]|False| if ID not found.
\end{itemize}

\paragraph{clear\_callbacks}

\begin{lstlisting}[style=pythonstyle]
def clear_callbacks(self):
\end{lstlisting}

\noindent Resets all registered callbacks.

\paragraph{async def process\_event}

\begin{lstlisting}[style=pythonstyle]
async def process_event(self, event_data: dict):
\end{lstlisting}

\noindent Processes a received event and triggers corresponding callbacks.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|event_data| (\lstinline[style=pythonstyle]|dict|): Event data in dictionary format.
\end{itemize}

\hrulefill

\subsection*{\texttt{pydoll.constants} Module}

\subsubsection*{\texttt{class pydoll.constants.By(str, Enum)}}
\noindent\texttt{class By(str, Enum)}

\noindent An enumeration of element selector strategies.

\paragraph{Enum Members}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|CSS_SELECTOR| (\lstinline[style=pythonstyle]|'css'|)
    \item \lstinline[style=pythonstyle]|XPATH| (\lstinline[style=pythonstyle]|'xpath'|)
    \item \lstinline[style=pythonstyle]|CLASS_NAME| (\lstinline[style=pythonstyle]|'class_name'|)
    \item \lstinline[style=pythonstyle]|ID| (\lstinline[style=pythonstyle]|'id'|)
    \item \lstinline[style=pythonstyle]|TAG_NAME| (\lstinline[style=pythonstyle]|'tag_name'|)
\end{itemize}

\subsubsection*{\texttt{class pydoll.constants.Scripts}}
\noindent\texttt{class Scripts()}

\noindent A class containing JavaScript code snippets (scripts) used for DOM interaction.

\paragraph{Class Attributes}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|ELEMENT_VISIBLE| (\lstinline[style=pythonstyle]|str|): JavaScript to check if an element is visible.
    \item \lstinline[style=pythonstyle]|ELEMENT_ON_TOP| (\lstinline[style=pythonstyle]|str|): JavaScript to check if an element is on top.
    \item \lstinline[style=pythonstyle]|CLICK| (\lstinline[style=pythonstyle]|str|): JavaScript to simulate a click on an element.
    \item \lstinline[style=pythonstyle]|CLICK_OPTION_TAG| (\lstinline[style=pythonstyle]|str|): JavaScript for clicking \lstinline[style=pythonstyle]|<option>| tags within \lstinline[style=pythonstyle]|<select>|.
    \item \lstinline[style=pythonstyle]|BOUNDS| (\lstinline[style=pythonstyle]|str|): JavaScript to get element bounding rectangle as JSON.
    \item \lstinline[style=pythonstyle]|FIND_RELATIVE_XPATH_ELEMENT| (\lstinline[style=pythonstyle]|str|): JavaScript to find an element by XPath relative to another element.
    \item \lstinline[style=pythonstyle]|FIND_XPATH_ELEMENT| (\lstinline[style=pythonstyle]|str|): JavaScript to find an element by XPath in the document.
    \item \lstinline[style=pythonstyle]|FIND_RELATIVE_XPATH_ELEMENTS| (\lstinline[style=pythonstyle]|str|): JavaScript to find elements by XPath relative to another element (multiple results).
    \item \lstinline[style=pythonstyle]|FIND_XPATH_ELEMENTS| (\lstinline[style=pythonstyle]|str|): JavaScript to find elements by XPath in the document (multiple results).
    \item \lstinline[style=pythonstyle]|QUERY_SELECTOR| (\lstinline[style=pythonstyle]|str|): JavaScript to query a single element using CSS selector.
    \item \lstinline[style=pythonstyle]|RELATIVE_QUERY_SELECTOR| (\lstinline[style=pythonstyle]|str|): JavaScript to query a single element using CSS selector relative to another element.
    \item \lstinline[style=pythonstyle]|QUERY_SELECTOR_ALL| (\lstinline[style=pythonstyle]|str|): JavaScript to query multiple elements using CSS selector.
    \item \lstinline[style=pythonstyle]|RELATIVE_QUERY_SELECTOR_ALL| (\lstinline[style=pythonstyle]|str|): JavaScript to query multiple elements using CSS selector relative to another element.
\end{itemize}

\hrulefill

\subsection*{\texttt{pydoll.element} Module}

\subsubsection*{\texttt{class pydoll.element.WebElement}}
\noindent\texttt{class WebElement(FindElementsMixin)}

\noindent Represents a DOM element on a web page.

\paragraph{Constructor}

\begin{lstlisting}[style=pythonstyle]
def __init__(self, object_id: str, connection_handler: ConnectionHandler, method: str = None, selector: str = None, attributes_list: list = []):
\end{lstlisting}

\noindent Initializes the \lstinline[style=pythonstyle]|WebElement| instance.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|object_id| (\lstinline[style=pythonstyle]|str|): The object ID of the DOM node from CDP.
    \item \lstinline[style=pythonstyle]|connection_handler| (\lstinline[style=pythonstyle]|ConnectionHandler|): The connection handler instance.
    \item \lstinline[style=pythonstyle]|method| (\lstinline[style=pythonstyle]|str|, optional): The method used to search for the element (e.g., \lstinline[style=pythonstyle]|By.CSS_SELECTOR|). Defaults to \lstinline[style=pythonstyle]|None|.
    \item \lstinline[style=pythonstyle]|selector| (\lstinline[style=pythonstyle]|str|, optional): The selector value used to find the element. Defaults to \lstinline[style=pythonstyle]|None|.
    \item \lstinline[style=pythonstyle]|attributes_list| (\lstinline[style=pythonstyle]|list|, optional): A list of attributes and values for the element, obtained from CDP\@. Defaults to \lstinline[style=pythonstyle]|[]|.
\end{itemize}

\paragraph{Properties}
\paragraph{value}

\begin{lstlisting}[style=pythonstyle]
value: str
\end{lstlisting}

\noindent Retrieves the \lstinline[style=pythonstyle]|value| attribute of the element.

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|str|: The value of the element, or \lstinline[style=pythonstyle]|None| if not found.
\end{itemize}

\paragraph{class\_name}

\begin{lstlisting}[style=pythonstyle]
class_name: str
\end{lstlisting}

\noindent Retrieves the \lstinline[style=pythonstyle]|class| attribute (mapped to \lstinline[style=pythonstyle]|class_name| property) of the element.

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|str|: The class name of the element, or \lstinline[style=pythonstyle]|None| if not found.
\end{itemize}

\paragraph{id}

\begin{lstlisting}[style=pythonstyle]
id: str
\end{lstlisting}

\noindent Retrieves the \lstinline[style=pythonstyle]|id| attribute of the element.

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|str|: The ID of the element, or \lstinline[style=pythonstyle]|None| if not found.
\end{itemize}

\paragraph{is\_enabled}

\begin{lstlisting}[style=pythonstyle]
is_enabled: bool
\end{lstlisting}

\noindent Retrieves the enabled status of the element, based on the presence of the \lstinline[style=pythonstyle]|`disabled'| attribute.

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|bool|: \lstinline[style=pythonstyle]|True| if the element is enabled (not disabled), \lstinline[style=pythonstyle]|False| otherwise.
\end{itemize}

\paragraph{async bounds}

\begin{lstlisting}[style=pythonstyle]
async bounds: list
\end{lstlisting}

\noindent Asynchronously retrieves the bounding box of the element using CDP's DOM API.

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|list|: The bounding box coordinates of the element.
\end{itemize}

\paragraph{async inner\_html}

\begin{lstlisting}[style=pythonstyle]
async inner_html: str
\end{lstlisting}

\noindent Asynchronously retrieves the inner HTML of the element.

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|str|: The inner HTML of the element.
\end{itemize}

\paragraph{Methods}
\paragraph{async def get\_bounds\_using\_js}

\begin{lstlisting}[style=pythonstyle]
async def get_bounds_using_js(self) -> list:
\end{lstlisting}

\noindent Retrieves the bounding box of the element using JavaScript execution.

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|list|: The bounding box coordinates of the element.
\end{itemize}

\paragraph{async def get\_screenshot}

\begin{lstlisting}[style=pythonstyle]
async def get_screenshot(self, path: str):
\end{lstlisting}

\noindent Takes a screenshot of the element and saves it to the specified path.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|path| (\lstinline[style=pythonstyle]|str|): The file path to save the screenshot to.
\end{itemize}

\paragraph{async def get\_element\_text}

\begin{lstlisting}[style=pythonstyle]
async def get_element_text(self) -> str:
\end{lstlisting}

\noindent Retrieves the text content of the element.

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|str|: The text content of the element, stripped of HTML tags.
\end{itemize}

\paragraph{get\_attribute}

\begin{lstlisting}[style=pythonstyle]
def get_attribute(self, name: str) -> str:
\end{lstlisting}

\noindent Retrieves the value of a specific attribute of the element.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|name| (\lstinline[style=pythonstyle]|str|): The name of the attribute to retrieve.
\end{itemize}

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|str|: The value of the attribute, or \lstinline[style=pythonstyle]|None| if the attribute is not present.
\end{itemize}

\paragraph{async def scroll\_into\_view}

\begin{lstlisting}[style=pythonstyle]
async def scroll_into_view(self):
\end{lstlisting}

\noindent Scrolls the element into view within the browser window.

\paragraph{async def click\_using\_js}

\begin{lstlisting}[style=pythonstyle]
async def click_using_js(self):
\end{lstlisting}

\noindent Clicks the element using JavaScript execution. This is useful for elements that are difficult to click directly due to overlapping elements.

\paragraph{Raises}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|ElementNotVisible|: If the element is not visible.
    \item \lstinline[style=pythonstyle]|ElementNotInteractable|: If the element is not interactable.
\end{itemize}

\paragraph{async def click}

\begin{lstlisting}[style=pythonstyle]
async def click(self, x_offset: int = 0, y_offset: int = 0):
\end{lstlisting}

\noindent Clicks the element by simulating mouse events at the element's center, with optional offsets.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|x_offset| (\lstinline[style=pythonstyle]|int|, optional): Horizontal offset from the element's center for the click position. Defaults to \lstinline[style=pythonstyle]|0|.
    \item \lstinline[style=pythonstyle]|y_offset| (\lstinline[style=pythonstyle]|int|, optional): Vertical offset from the element's center for the click position. Defaults to \lstinline[style=pythonstyle]|0|.
\end{itemize}

\paragraph{Raises}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|ElementNotVisible|: If the element is not visible.
\end{itemize}

\paragraph{async def click\_option\_tag}

\begin{lstlisting}[style=pythonstyle]
async def click_option_tag(self):
\end{lstlisting}

\noindent Clicks an \lstinline[style=pythonstyle]|<option>| tag element, specifically designed for \lstinline[style=pythonstyle]|<select>| dropdowns.

\paragraph{async def send\_keys}

\begin{lstlisting}[style=pythonstyle]
async def send_keys(self, text: str):
\end{lstlisting}

\noindent Sends a sequence of keys to the element, simulating typing.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|text| (\lstinline[style=pythonstyle]|str|): The text to send.
\end{itemize}

\paragraph{async def type\_keys}

\begin{lstlisting}[style=pythonstyle]
async def type_keys(self, text: str):
\end{lstlisting}

\noindent Types text into the element in a more realistic manner, sending keys one by one with a small delay.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|text| (\lstinline[style=pythonstyle]|str|): The text to type.
\end{itemize}

\hrulefill

\subsection*{\texttt{pydoll.events} Module}

\subsubsection*{\texttt{pydoll.events.browser} Module}

\subsubsection*{\texttt{class pydoll.events.browser.BrowserEvents}}
\noindent A class to define the browser events available through the Chrome DevTools Protocol (CDP). These events allow for monitoring specific actions and states within the browser, such as downloads.

\paragraph{Class Attributes}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|DOWNLOAD_PROGRESS| (\lstinline[style=pythonstyle]|str|): Event triggered when download progress updates.
    \item \lstinline[style=pythonstyle]|DOWNLOAD_WILL_BEGIN| (\lstinline[style=pythonstyle]|str|): Event triggered when a download is about to start.
\end{itemize}

\subsubsection*{\texttt{pydoll.events.dom} Module}

\subsubsection*{\texttt{class pydoll.events.dom.DomEvents}}
\noindent A class to define the DOM events available through the Chrome DevTools Protocol (CDP). These events allow for monitoring changes and updates within the Document Object Model (DOM) of a web page, enabling developers to react to specific modifications and interactions with the DOM elements.

\paragraph{Class Attributes}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|ATTRIBUTE_MODIFIED| (\lstinline[style=pythonstyle]|str|): Event triggered when an attribute of a DOM node is modified.
    \item \lstinline[style=pythonstyle]|ATTRIBUTE_REMOVED| (\lstinline[style=pythonstyle]|str|): Event triggered when an attribute of a DOM node is removed.
    \item \lstinline[style=pythonstyle]|CHARACTER_DATA_MODIFIED| (\lstinline[style=pythonstyle]|str|): Event triggered when the character data of a DOM node is modified.
    \item \lstinline[style=pythonstyle]|CHILD_NODE_COUNT_UPDATED| (\lstinline[style=pythonstyle]|str|): Event triggered when the number of child nodes of a DOM node is updated.
    \item \lstinline[style=pythonstyle]|CHILD_NODE_INSERTED| (\lstinline[style=pythonstyle]|str|): Event triggered when a new child node is inserted into a DOM node.
    \item \lstinline[style=pythonstyle]|CHILD_NODE_REMOVED| (\lstinline[style=pythonstyle]|str|): Event triggered when a child node is removed from a DOM node.
    \item \lstinline[style=pythonstyle]|DOCUMENT_UPDATED| (\lstinline[style=pythonstyle]|str|): Event triggered when the DOM document is updated.
    \item \lstinline[style=pythonstyle]|SCROLLABLE_FLAG_UPDATED| (\lstinline[style=pythonstyle]|str|): Event triggered when the scrollable flag of a DOM node is updated.
    \item \lstinline[style=pythonstyle]|SHADOW_ROOT_POPPED| (\lstinline[style=pythonstyle]|str|): Event triggered when a shadow root is popped from the stack.
    \item \lstinline[style=pythonstyle]|SHADOW_ROOT_PUSHED| (\lstinline[style=pythonstyle]|str|): Event triggered when a shadow root is pushed onto the stack.
    \item \lstinline[style=pythonstyle]|TOP_LAYER_ELEMENTS_UPDATED| (\lstinline[style=pythonstyle]|str|): Event triggered when the top layer elements in the DOM are updated.
\end{itemize}

\subsubsection*{\texttt{pydoll.events.fetch} Module}

\subsubsection*{\texttt{class pydoll.events.fetch.FetchEvents}}
\noindent A class to define the Fetch events available through the Chrome DevTools Protocol (CDP). These events are related to the management of network requests, allowing developers to intercept, modify, and monitor HTTP requests and responses made by the browser.

\paragraph{Class Attributes}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|AUTH_REQUIRED| (\lstinline[style=pythonstyle]|str|): Event triggered when authentication is required for a network request.
    \item \lstinline[style=pythonstyle]|REQUEST_PAUSED| (\lstinline[style=pythonstyle]|str|): Event triggered when a network request is paused.
\end{itemize}

\subsubsection*{\texttt{pydoll.events.network} Module}

\subsubsection*{\texttt{class pydoll.events.network.NetworkEvents}}
\noindent A class that defines constants for various network-related events. These constants can be used to identify and handle network interactions in applications, particularly in event-driven architectures or APIs that monitor network activity.

\paragraph{Class Attributes}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|DATA_RECEIVED| (\lstinline[style=pythonstyle]|str|): Event triggered when data is received over the network.
    \item \lstinline[style=pythonstyle]|EVENT_SOURCE_MESSAGE_RECEIVED| (\lstinline[style=pythonstyle]|str|): Event fired when a message is received from an EventSource.
    \item \lstinline[style=pythonstyle]|LOADING_FAILED| (\lstinline[style=pythonstyle]|str|): Event that indicates a failure in loading a network resource.
    \item \lstinline[style=pythonstyle]|LOADING_FINISHED| (\lstinline[style=pythonstyle]|str|): Event fired when a network loading operation is completed.
    \item \lstinline[style=pythonstyle]|REQUEST_SERVED_FROM_CACHE| (\lstinline[style=pythonstyle]|str|): Event indicating that a network request was fulfilled from the cache.
    \item \lstinline[style=pythonstyle]|REQUEST_WILL_BE_SENT| (\lstinline[style=pythonstyle]|str|): Event triggered just before a network request is sent.
    \item \lstinline[style=pythonstyle]|RESPONSE_RECEIVED| (\lstinline[style=pythonstyle]|str|): Event that indicates a response has been received from a network request.
    \item \lstinline[style=pythonstyle]|WEB_SOCKET_CLOSED| (\lstinline[style=pythonstyle]|str|): Event that occurs when a WebSocket connection has been closed.
    \item \lstinline[style=pythonstyle]|WEB_SOCKET_CREATED| (\lstinline[style=pythonstyle]|str|): Event fired when a new WebSocket connection is established.
    \item \lstinline[style=pythonstyle]|WEB_SOCKET_FRAME_ERROR| (\lstinline[style=pythonstyle]|str|): Event indicating that there was an error with a frame in a WebSocket communication.
    \item \lstinline[style=pythonstyle]|WEB_SOCKET_FRAME_RECEIVED| (\lstinline[style=pythonstyle]|str|): Event fired when a frame is received through a WebSocket.
    \item \lstinline[style=pythonstyle]|WEB_SOCKET_FRAME_SENT| (\lstinline[style=pythonstyle]|str|): Event representing a frame that has been sent through a WebSocket.
    \item \lstinline[style=pythonstyle]|WEB_TRANSPORT_CLOSED| (\lstinline[style=pythonstyle]|str|): Event indicating that a web transport connection has been closed.
    \item \lstinline[style=pythonstyle]|WEB_TRANSPORT_CONNECTION_ESTABLISHED| (\lstinline[style=pythonstyle]|str|): Event fired when a web transport connection is successfully established.
    \item \lstinline[style=pythonstyle]|WEB_TRANSPORT_CREATED| (\lstinline[style=pythonstyle]|str|): Event that signifies that a new web transport connection has been created.
    \item \lstinline[style=pythonstyle]|POLICY_UPDATED| (\lstinline[style=pythonstyle]|str|): Event that indicates that the network policy has been updated.
    \item \lstinline[style=pythonstyle]|REQUEST_INTERCEPTED| (\lstinline[style=pythonstyle]|str|): Event fired when a network request has been intercepted.
\end{itemize}

\subsubsection*{\texttt{pydoll.events.page} Module}

\subsubsection*{\texttt{class pydoll.events.page.PageEvents}}
\noindent A class that defines constants for various page-related events. These constants represent significant events in the lifecycle of a web page, particularly in the context of web automation, testing, or monitoring.

\paragraph{Class Attributes}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|PAGE_LOADED| (\lstinline[style=pythonstyle]|str|): Event triggered when the page has fully loaded.
    \item \lstinline[style=pythonstyle]|DOM_CONTENT_LOADED| (\lstinline[style=pythonstyle]|str|): Event fired when the DOMContentLoaded event is fired.
    \item \lstinline[style=pythonstyle]|FILE_CHOOSER_OPENED| (\lstinline[style=pythonstyle]|str|): Event indicating that a file chooser dialog has been opened.
    \item \lstinline[style=pythonstyle]|FRAME_ATTACHED| (\lstinline[style=pythonstyle]|str|): Event that occurs when a frame is attached to the page.
    \item \lstinline[style=pythonstyle]|FRAME_DETACHED| (\lstinline[style=pythonstyle]|str|): Event triggered when a frame is detached from the page.
    \item \lstinline[style=pythonstyle]|FRAME_NAVIGATED| (\lstinline[style=pythonstyle]|str|): Event that indicates a frame has been navigated to a new URL.
    \item \lstinline[style=pythonstyle]|JS_DIALOG_CLOSED| (\lstinline[style=pythonstyle]|str|): Event fired when a JavaScript dialog (such as an alert or confirmation) is closed.
    \item \lstinline[style=pythonstyle]|JS_DIALOG_OPENING| (\lstinline[style=pythonstyle]|str|): Event triggered when a JavaScript dialog is about to open.
    \item \lstinline[style=pythonstyle]|LIFECYCLE_EVENT| (\lstinline[style=pythonstyle]|str|): Event representing a generic lifecycle event for the page.
    \item \lstinline[style=pythonstyle]|WINDOW_OPENED| (\lstinline[style=pythonstyle]|str|): Event that indicates a new window has been opened.
    \item \lstinline[style=pythonstyle]|DOCUMENT_OPENED| (\lstinline[style=pythonstyle]|str|): Event that signifies a new document has been opened in the page.
    \item \lstinline[style=pythonstyle]|FRAME_STARTED_LOADING| (\lstinline[style=pythonstyle]|str|): Event triggered when a frame starts loading content.
    \item \lstinline[style=pythonstyle]|FRAME_STOPPED_LOADING| (\lstinline[style=pythonstyle]|str|): Event that indicates a frame has stopped loading content.
    \item \lstinline[style=pythonstyle]|DOWNLOAD_PROGRESS| (\lstinline[style=pythonstyle]|str|): Event fired to indicate progress on a download operation.
    \item \lstinline[style=pythonstyle]|DOWNLOAD_WILL_BEGIN| (\lstinline[style=pythonstyle]|str|): Event that occurs when a download is about to start.
    \item \lstinline[style=pythonstyle]|NAVIGATED_WITHIN_DOCUMENT| (\lstinline[style=pythonstyle]|str|): Event that indicates navigation within the same document.
\end{itemize}

\hrulefill

\subsection*{\texttt{pydoll.exceptions} Module}

\paragraph{Exceptions}
\begin{itemize}
    \item \lstinline[style=pythonstyle]|ConnectionFailed|: Exception raised when connection to the browser fails.
    \item \lstinline[style=pythonstyle]|InvalidCommand|: Exception raised when an invalid command is provided.
    \item \lstinline[style=pythonstyle]|InvalidCallback|: Exception raised when an invalid callback is provided.
    \item \lstinline[style=pythonstyle]|NetworkError|: Exception raised when a network error occurs.
    \item \lstinline[style=pythonstyle]|InvalidResponse|: Exception raised when an invalid response is received.
    \item \lstinline[style=pythonstyle]|ReconnectionFailed|: Exception raised when reconnection to the browser fails.
    \item \lstinline[style=pythonstyle]|ResendCommandFailed|: Exception raised when resending a command fails.
    \item \lstinline[style=pythonstyle]|BrowserNotRunning|: Exception raised when the browser is not running.
    \item \lstinline[style=pythonstyle]|ElementNotFound|: Exception raised when an element is not found.
    \item \lstinline[style=pythonstyle]|ClickIntercepted|: Exception raised when a click is intercepted.
    \item \lstinline[style=pythonstyle]|ElementNotVisible|: Exception raised when an element is not visible.
    \item \lstinline[style=pythonstyle]|ElementNotInteractable|: Exception raised when an element is not interactable.
    \item \lstinline[style=pythonstyle]|InvalidFileExtension|: Exception raised when an invalid file extension is provided for file operations.
\end{itemize}

\hrulefill

\subsection*{\texttt{pydoll.mixins} Module}

\subsubsection*{\texttt{pydoll.mixins.find\_elements} Module}

\subsubsection*{\texttt{class pydoll.mixins.find\_elements.FindElementsMixin}}
\noindent Mixin class providing methods for finding elements within a Page or WebElement.

\paragraph{Methods}
\paragraph{async def wait\_element}

\begin{lstlisting}[style=pythonstyle]
async def wait_element(self, by: DomCommands.SelectorType, value: str, timeout: int = 10, raise_exc: bool = True) -> WebElement | None:
\end{lstlisting}

\noindent Waits for an element to be present in the DOM.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|by| (\lstinline[style=pythonstyle]|SelectorType|): The type of selector to use (e.g., \lstinline[style=pythonstyle]|By.CSS_SELECTOR|, \lstinline[style=pythonstyle]|By.XPATH|).
    \item \lstinline[style=pythonstyle]|value| (\lstinline[style=pythonstyle]|str|): The selector value.
    \item \lstinline[style=pythonstyle]|timeout| (\lstinline[style=pythonstyle]|int|, optional): Time in seconds to wait for the element. Defaults to \lstinline[style=pythonstyle]|10|.
    \item \lstinline[style=pythonstyle]|raise_exc| (\lstinline[style=pythonstyle]|bool|, optional): Whether to raise \lstinline[style=pythonstyle]|TimeoutError| if the element is not found within the timeout. Defaults to \lstinline[style=pythonstyle]|True|.
\end{itemize}

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|WebElement | None|: The \lstinline[style=pythonstyle]|WebElement| instance if found, \lstinline[style=pythonstyle]|None| if not found and \lstinline[style=pythonstyle]|raise_exc| is \lstinline[style=pythonstyle]|False|.
\end{itemize}

\paragraph{Raises}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|TimeoutError|: If the element is not found within the timeout and \lstinline[style=pythonstyle]|raise_exc| is \lstinline[style=pythonstyle]|True|.
\end{itemize}

\paragraph{async def find\_element}

\begin{lstlisting}[style=pythonstyle]
async def find_element(self, by: DomCommands.SelectorType, value: str, raise_exc: bool = True) -> WebElement | None:
\end{lstlisting}

\noindent Finds a single element on the current page or within the current element context using the specified selector.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|by| (\lstinline[style=pythonstyle]|SelectorType|): The type of selector to use (e.g., \lstinline[style=pythonstyle]|By.CSS_SELECTOR|, \lstinline[style=pythonstyle]|By.XPATH|).
    \item \lstinline[style=pythonstyle]|value| (\lstinline[style=pythonstyle]|str|): The selector value.
    \item \lstinline[style=pythonstyle]|raise_exc| (\lstinline[style=pythonstyle]|bool|, optional): Whether to raise \lstinline[style=pythonstyle]|ElementNotFound| exception if element is not found. Defaults to \lstinline[style=pythonstyle]|True|.
\end{itemize}

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|WebElement | None|: The \lstinline[style=pythonstyle]|WebElement| instance if found, \lstinline[style=pythonstyle]|None| if not found and \lstinline[style=pythonstyle]|raise_exc| is \lstinline[style=pythonstyle]|False|.
\end{itemize}

\paragraph{Raises}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|ElementNotFound|: If the element is not found and \lstinline[style=pythonstyle]|raise_exc| is \lstinline[style=pythonstyle]|True|.
\end{itemize}

\paragraph{async def find\_elements}

\begin{lstlisting}[style=pythonstyle]
async def find_elements(self, by: DomCommands.SelectorType, value: str, raise_exc: bool = True) -> list[WebElement]:
\end{lstlisting}

\noindent Finds all elements on the current page or within the current element context using the specified selector.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|by| (\lstinline[style=pythonstyle]|SelectorType|): The type of selector to use (e.g., \lstinline[style=pythonstyle]|By.CSS_SELECTOR|, \lstinline[style=pythonstyle]|By.XPATH|).
    \item \lstinline[style=pythonstyle]|value| (\lstinline[style=pythonstyle]|str|): The selector value.
    \item \lstinline[style=pythonstyle]|raise_exc| (\lstinline[style=pythonstyle]|bool|, optional): Whether to raise \lstinline[style=pythonstyle]|ElementNotFound| exception if no elements are found. Defaults to \lstinline[style=pythonstyle]|True|.
\end{itemize}

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|list[WebElement]|: A list of \lstinline[style=pythonstyle]|WebElement| instances found, or an empty list if no elements are found and \lstinline[style=pythonstyle]|raise_exc| is \lstinline[style=pythonstyle]|False|.
\end{itemize}

\paragraph{Raises}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|ElementNotFound|: If no elements are found and \lstinline[style=pythonstyle]|raise_exc| is \lstinline[style=pythonstyle]|True|.
\end{itemize}

\hrulefill

\subsection*{\texttt{pydoll.utils} Module}

\subsubsection*{\texttt{pydoll.utils.decode\_image\_to\_bytes(image: str) -> bytes}}
\noindent Decodes a base64 image string to bytes.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|image| (\lstinline[style=pythonstyle]|str|): The base64 image string to decode.
\end{itemize}

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|bytes|: The decoded image as bytes.
\end{itemize}

\subsubsection*{\texttt{pydoll.utils.get\_browser\_ws\_address(port: int) -> str}}
\noindent Fetches the WebSocket address for the browser instance.

\paragraph{Arguments}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|port| (\lstinline[style=pythonstyle]|int|): The port number of the Chrome DevTools instance.
\end{itemize}

\paragraph{Returns}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|str|: The WebSocket address for the browser.
\end{itemize}

\paragraph{Raises}

\begin{itemize}
    \item \lstinline[style=pythonstyle]|NetworkError|: If the address cannot be fetched due to network errors.
    \item \lstinline[style=pythonstyle]|InvalidResponse|: If the response from the browser is invalid or does not contain the WebSocket address.
\end{itemize}

\end{document}